/******/ (function(modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {}; // The require function
    /******/
    /******/ /******/ function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/ if (installedModules[moduleId]) {
            /******/ return installedModules[moduleId].exports;
            /******/
        } // Create a new module (and put it into the cache)
        /******/ /******/ var module = (installedModules[moduleId] = {
            /******/ i: moduleId,
            /******/ l: false,
            /******/ exports: {},
            /******/
        }); // Execute the module function
        /******/
        /******/ /******/ modules[moduleId].call(
            module.exports,
            module,
            module.exports,
            __webpack_require__,
        ); // Flag the module as loaded
        /******/
        /******/ /******/ module.l = true; // Return the exports of the module
        /******/
        /******/ /******/ return module.exports;
        /******/
    } // expose the modules object (__webpack_modules__)
    /******/
    /******/
    /******/ /******/ __webpack_require__.m = modules; // expose the module cache
    /******/
    /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
    /******/
    /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
        /******/ if (!__webpack_require__.o(exports, name)) {
            /******/ Object.defineProperty(exports, name, {
                enumerable: true,
                get: getter,
            });
            /******/
        }
        /******/
    }; // define __esModule on exports
    /******/
    /******/ /******/ __webpack_require__.r = function(exports) {
        /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                value: "Module",
            });
            /******/
        }
        /******/ Object.defineProperty(exports, "__esModule", {value: true});
        /******/
    }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
    /******/
    /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
        value,
        mode,
    ) {
        /******/ if (mode & 1) value = __webpack_require__(value);
        /******/ if (mode & 8) return value;
        /******/ if (
            mode & 4 &&
            typeof value === "object" &&
            value &&
            value.__esModule
        )
            return value;
        /******/ var ns = Object.create(null);
        /******/ __webpack_require__.r(ns);
        /******/ Object.defineProperty(ns, "default", {
            enumerable: true,
            value: value,
        });
        /******/ if (mode & 2 && typeof value != "string")
            for (var key in value)
                __webpack_require__.d(
                    ns,
                    key,
                    function(key) {
                        return value[key];
                    }.bind(null, key),
                );
        /******/ return ns;
        /******/
    }; // getDefaultExport function for compatibility with non-harmony modules
    /******/
    /******/ /******/ __webpack_require__.n = function(module) {
        /******/ var getter =
            module && module.__esModule
                ? /******/ function getDefault() {
                      return module["default"];
                  }
                : /******/ function getModuleExports() {
                      return module;
                  };
        /******/ __webpack_require__.d(getter, "a", getter);
        /******/ return getter;
        /******/
    }; // Object.prototype.hasOwnProperty.call
    /******/
    /******/ /******/ __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }; // __webpack_public_path__
    /******/
    /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
    /******/
    /******/
    /******/ /******/ return __webpack_require__(
        (__webpack_require__.s = "./src/index.js"),
    );
    /******/
})(
    /************************************************************************/
    /******/ {
        /***/ "./src/LiterallyCanvas.js":
            /*!********************************!*\
  !*** ./src/LiterallyCanvas.js ***!
  \********************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions */ "./src/actions.js");\n/* harmony import */ var _bindEvents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bindEvents */ "./src/bindEvents.js");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes */ "./src/shapes.js");\n/* harmony import */ var _canvasRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvasRenderer */ "./src/canvasRenderer.js");\n/* harmony import */ var _defaultOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultOptions */ "./src/defaultOptions.js");\n/* harmony import */ var _renderSnapshotToImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderSnapshotToImage */ "./src/renderSnapshotToImage.js");\n/* harmony import */ var _renderSnapshotToSVG__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderSnapshotToSVG */ "./src/renderSnapshotToSVG.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util */ "./src/util.js");\n\n\n\n\n\n\n\n\n\nconst INFINITE = "infinite";\n\nclass LiterallyCanvas {\n    constructor(arg1, arg2) {\n        this.setImageSize = this.setImageSize.bind(this);\n        let opts = null;\n        let containerEl = null;\n        if (arg1 instanceof HTMLElement) {\n            containerEl = arg1;\n            opts = arg2;\n        } else {\n            opts = arg1;\n        }\n\n        this.opts = opts || {};\n\n        this.config = {\n            zoomMin: opts.zoomMin || 0.2,\n            zoomMax: opts.zoomMax || 4.0,\n            zoomStep: opts.zoomStep || 0.2,\n        };\n\n        this.colors = {\n            primary: opts.primaryColor || "#000",\n            secondary: opts.secondaryColor || "#fff",\n            background: opts.backgroundColor || "transparent",\n        };\n\n        this.watermarkImage = opts.watermarkImage;\n        this.watermarkScale = opts.watermarkScale || 1;\n\n        this.backgroundCanvas = document.createElement("canvas");\n        this.backgroundCtx = this.backgroundCanvas.getContext("2d");\n\n        this.canvas = document.createElement("canvas");\n        this.canvas.style["background-color"] = "transparent";\n\n        this.buffer = document.createElement("canvas");\n        this.buffer.style["background-color"] = "transparent";\n        this.ctx = this.canvas.getContext("2d");\n        this.bufferCtx = this.buffer.getContext("2d");\n\n        this.backingScale = Object(_util__WEBPACK_IMPORTED_MODULE_7__["getBackingScale"])(this.ctx);\n\n        this.backgroundShapes = opts.backgroundShapes || [];\n        this._shapesInProgress = [];\n        this.shapes = [];\n        this.undoStack = [];\n        this.redoStack = [];\n\n        this.isDragging = false;\n        this.position = {x: 0, y: 0};\n        this.scale = 1.0;\n        // GUI immediately replaces this value, but it\'s initialized so you can have\n        // something really simple\n        this.setTool(new this.opts.tools[0](this));\n\n        this.width = opts.imageSize.width || INFINITE;\n        this.height = opts.imageSize.height || INFINITE;\n\n        // This will ensure that we are zoomed to @scale, panned to @position, and\n        // that all layers are repainted.\n        this.setZoom(this.scale);\n\n        if (opts.snapshot) {\n            this.loadSnapshot(opts.snapshot);\n        }\n\n        this.isBound = false;\n        if (containerEl) {\n            this.bindToElement(containerEl);\n        }\n\n        this.respondToSizeChange = function() {};\n    }\n\n    bindToElement(containerEl) {\n        if (this.containerEl) {\n            console.warn(\n                "Trying to bind Literally Canvas to a DOM element more than once is unsupported.",\n            );\n            return;\n        }\n\n        this.containerEl = containerEl;\n        this._unsubscribeEvents = Object(_bindEvents__WEBPACK_IMPORTED_MODULE_1__["default"])(\n            this,\n            this.containerEl,\n            this.opts.keyboardShortcuts,\n        );\n        this.containerEl.style["background-color"] = this.colors.background;\n        this.containerEl.appendChild(this.backgroundCanvas);\n        this.containerEl.appendChild(this.canvas);\n\n        this.isBound = true;\n\n        const repaintAll = () => {\n            this.keepPanInImageBounds();\n            this.repaintAllLayers();\n        };\n\n        this.respondToSizeChange = Object(_util__WEBPACK_IMPORTED_MODULE_7__["matchElementSize"])(\n            this.containerEl,\n            [this.backgroundCanvas, this.canvas],\n            this.backingScale,\n            repaintAll,\n        );\n\n        if (this.watermarkImage) {\n            this.watermarkImage.onload = () => this.repaintLayer("background");\n        }\n\n        if (this.tool != null) {\n            this.tool.didBecomeActive(this);\n        }\n\n        repaintAll();\n    }\n\n    _teardown() {\n        if (this.tool != null) {\n            this.tool.willBecomeInactive(this);\n        }\n        if (typeof this._unsubscribeEvents === "function") {\n            this._unsubscribeEvents();\n        }\n        this.tool = null;\n        this.containerEl = null;\n        this.isBound = false;\n    }\n\n    trigger(name, data) {\n        this.canvas.dispatchEvent(new CustomEvent(name, {detail: data}));\n        // dispatchEvent has a boolean value that doesn\'t mean anything to us, so\n        // don\'t let CoffeeScript send it back\n        return null;\n    }\n\n    on(name, fn) {\n        const wrapper = e => fn(e.detail);\n        this.canvas.addEventListener(name, wrapper);\n        return () => {\n            this.canvas.removeEventListener(name, wrapper);\n        };\n    }\n\n    // actual ratio of drawing-space pixels to perceived pixels, accounting for\n    // both zoom and displayPixelWidth. use this when converting between\n    // drawing-space and screen-space.\n    getRenderScale() {\n        return this.scale * this.backingScale;\n    }\n\n    clientCoordsToDrawingCoords(x, y) {\n        return {\n            x:\n                (x * this.backingScale - this.position.x) /\n                this.getRenderScale(),\n            y:\n                (y * this.backingScale - this.position.y) /\n                this.getRenderScale(),\n        };\n    }\n\n    drawingCoordsToClientCoords(x, y) {\n        return {\n            x: x * this.getRenderScale() + this.position.x,\n            y: y * this.getRenderScale() + this.position.y,\n        };\n    }\n\n    setImageSize(width, height) {\n        this.width = width || INFINITE;\n        this.height = height || INFINITE;\n        this.keepPanInImageBounds();\n        this.repaintAllLayers();\n        this.trigger("imageSizeChange", {\n            width: this.width,\n            height: this.height,\n        });\n    }\n\n    setTool(tool) {\n        if (this.isBound) {\n            if (this.tool != null) {\n                this.tool.willBecomeInactive(this);\n            }\n        }\n        this.tool = tool;\n        this.trigger("toolChange", {tool});\n        if (this.isBound) {\n            this.tool.didBecomeActive(this);\n        }\n    }\n\n    setShapesInProgress(newVal) {\n        this._shapesInProgress = newVal;\n    }\n\n    pointerDown(x, y) {\n        const p = this.clientCoordsToDrawingCoords(x, y);\n        if (this.tool.usesSimpleAPI) {\n            this.tool.begin(p.x, p.y, this);\n            this.isDragging = true;\n            this.trigger("drawStart", {tool: this.tool});\n        } else {\n            this.isDragging = true;\n            this.trigger("lc-pointerdown", {\n                tool: this.tool,\n                x: p.x,\n                y: p.y,\n                rawX: x,\n                rawY: y,\n            });\n        }\n    }\n\n    pointerMove(x, y) {\n        // FIXME: requestAnimationFrame returns a value to be used in order to\n        // cancel animationFrame when it is no longer required...\n        Object(_util__WEBPACK_IMPORTED_MODULE_7__["requestAnimationFrame"])(() => {\n            const p = this.clientCoordsToDrawingCoords(x, y);\n            if (this.tool != null ? this.tool.usesSimpleAPI : undefined) {\n                if (this.isDragging) {\n                    this.tool.continue(p.x, p.y, this);\n                    this.trigger("drawContinue", {tool: this.tool});\n                }\n            } else {\n                if (this.isDragging) {\n                    this.trigger("lc-pointerdrag", {\n                        tool: this.tool,\n                        x: p.x,\n                        y: p.y,\n                        rawX: x,\n                        rawY: y,\n                    });\n                } else {\n                    this.trigger("lc-pointermove", {\n                        tool: this.tool,\n                        x: p.x,\n                        y: p.y,\n                        rawX: x,\n                        rawY: y,\n                    });\n                }\n            }\n        });\n    }\n\n    pointerUp(x, y) {\n        const p = this.clientCoordsToDrawingCoords(x, y);\n        if (this.tool.usesSimpleAPI) {\n            if (this.isDragging) {\n                this.tool.end(p.x, p.y, this);\n                this.isDragging = false;\n                this.trigger("drawEnd", {tool: this.tool});\n            }\n        } else {\n            this.isDragging = false;\n            this.trigger("lc-pointerup", {\n                tool: this.tool,\n                x: p.x,\n                y: p.y,\n                rawX: x,\n                rawY: y,\n            });\n        }\n    }\n\n    setColor(name, color) {\n        this.colors[name] = color;\n        if (!this.isBound) {\n            return;\n        }\n        switch (name) {\n            case "background":\n                this.containerEl.style.backgroundColor = this.colors.background;\n                this.repaintLayer("background");\n                break;\n            case "primary":\n                this.repaintLayer("main");\n                break;\n            case "secondary":\n                this.repaintLayer("main");\n                break;\n        }\n        this.trigger(`${name}ColorChange`, this.colors[name]);\n        if (name === "background") {\n            this.trigger("drawingChange");\n        }\n    }\n\n    getColor(name) {\n        return this.colors[name];\n    }\n\n    saveShape(shape, triggerShapeSaveEvent, previousShapeId = null) {\n        if (triggerShapeSaveEvent == null) {\n            triggerShapeSaveEvent = true;\n        }\n        if (!previousShapeId) {\n            previousShapeId = this.shapes.length\n                ? this.shapes[this.shapes.length - 1].id\n                : null;\n        }\n        this.execute(new _actions__WEBPACK_IMPORTED_MODULE_0__["AddShapeAction"](this, shape, previousShapeId));\n        if (triggerShapeSaveEvent) {\n            this.trigger("shapeSave", {shape, previousShapeId});\n        }\n        this.trigger("drawingChange");\n    }\n\n    pan(x, y) {\n        // Subtract because we are moving the viewport\n        this.setPan(this.position.x - x, this.position.y - y);\n    }\n\n    keepPanInImageBounds() {\n        const renderScale = this.getRenderScale();\n        let {x, y} = this.position;\n\n        if (this.width !== INFINITE) {\n            if (this.canvas.width > this.width * renderScale) {\n                x = (this.canvas.width - this.width * renderScale) / 2;\n            } else {\n                x = Math.max(\n                    Math.min(0, x),\n                    this.canvas.width - this.width * renderScale,\n                );\n            }\n        }\n\n        if (this.height !== INFINITE) {\n            if (this.canvas.height > this.height * renderScale) {\n                y = (this.canvas.height - this.height * renderScale) / 2;\n            } else {\n                y = Math.max(\n                    Math.min(0, y),\n                    this.canvas.height - this.height * renderScale,\n                );\n            }\n        }\n\n        this.position = {x, y};\n    }\n\n    setPan(x, y) {\n        this.position = {x, y};\n        this.keepPanInImageBounds();\n        this.repaintAllLayers();\n        this.trigger("pan", {x: this.position.x, y: this.position.y});\n    }\n\n    zoom(factor) {\n        let newScale = this.scale + factor;\n        newScale = Math.max(newScale, this.config.zoomMin);\n        newScale = Math.min(newScale, this.config.zoomMax);\n        newScale = Math.round(newScale * 100) / 100;\n        this.setZoom(newScale);\n    }\n\n    setZoom(scale) {\n        const center = this.clientCoordsToDrawingCoords(\n            this.canvas.width / 2,\n            this.canvas.height / 2,\n        );\n        const oldScale = this.scale;\n        this.scale = scale;\n\n        this.position.x =\n            (this.canvas.width / 2) * this.backingScale -\n            center.x * this.getRenderScale();\n        this.position.y =\n            (this.canvas.height / 2) * this.backingScale -\n            center.y * this.getRenderScale();\n\n        this.keepPanInImageBounds();\n\n        this.repaintAllLayers();\n        this.trigger("zoom", {oldScale, newScale: this.scale});\n    }\n\n    setWatermarkImage(newImage) {\n        this.watermarkImage = newImage;\n        Object(_util__WEBPACK_IMPORTED_MODULE_7__["addImageOnload"])(newImage, () => this.repaintLayer("background"));\n        if (newImage.width) {\n            this.repaintLayer("background");\n        }\n    }\n\n    repaintAllLayers() {\n        for (let key of ["background", "main"]) {\n            this.repaintLayer(key);\n        }\n        return null;\n    }\n\n    // Repaints the canvas.\n    // If dirty is true then all saved shapes are completely redrawn,\n    // otherwise the back buffer is simply copied to the screen as is.\n    repaintLayer(repaintLayerKey, dirty) {\n        if (dirty == null) {\n            dirty = repaintLayerKey === "main";\n        }\n        if (!this.isBound) {\n            return;\n        }\n        switch (repaintLayerKey) {\n            case "background":\n                this.backgroundCtx.clearRect(\n                    0,\n                    0,\n                    this.backgroundCanvas.width,\n                    this.backgroundCanvas.height,\n                );\n                var retryCallback = () => this.repaintLayer("background");\n                if (this.watermarkImage) {\n                    this._renderWatermark(\n                        this.backgroundCtx,\n                        true,\n                        retryCallback,\n                    );\n                }\n                this.draw(\n                    this.backgroundShapes,\n                    this.backgroundCtx,\n                    retryCallback,\n                );\n                break;\n            case "main":\n                retryCallback = () => this.repaintLayer("main", true);\n                if (dirty) {\n                    this.buffer.width = this.canvas.width;\n                    this.buffer.height = this.canvas.height;\n                    this.bufferCtx.clearRect(\n                        0,\n                        0,\n                        this.buffer.width,\n                        this.buffer.height,\n                    );\n                    this.draw(this.shapes, this.bufferCtx, retryCallback);\n                }\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                if (this.canvas.width > 0 && this.canvas.height > 0) {\n                    this.ctx.fillStyle = "#ccc";\n                    this.ctx.fillRect(\n                        0,\n                        0,\n                        this.canvas.width,\n                        this.canvas.height,\n                    );\n                    this.clipped(() => {\n                        this.ctx.clearRect(\n                            0,\n                            0,\n                            this.canvas.width,\n                            this.canvas.height,\n                        );\n                        this.ctx.drawImage(this.buffer, 0, 0);\n                    }, this.ctx);\n\n                    this.clipped(\n                        () => {\n                            this.transformed(\n                                () => {\n                                    this._shapesInProgress.map(shape =>\n                                        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_3__["renderShapeToContext"])(this.ctx, shape, {\n                                            bufferCtx: this.bufferCtx,\n                                            shouldOnlyDrawLatest: true,\n                                        }),\n                                    );\n                                },\n                                this.ctx,\n                                this.bufferCtx,\n                            );\n                        },\n                        this.ctx,\n                        this.bufferCtx,\n                    );\n                }\n                break;\n        }\n\n        this.trigger("repaint", {layerKey: repaintLayerKey});\n    }\n\n    _renderWatermark(ctx, worryAboutRetina, retryCallback) {\n        if (worryAboutRetina == null) {\n            worryAboutRetina = true;\n        }\n        if (!this.watermarkImage.width) {\n            this.watermarkImage.onload = retryCallback;\n            return;\n        }\n\n        ctx.save();\n        ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\n        ctx.scale(this.watermarkScale, this.watermarkScale);\n        if (worryAboutRetina) {\n            ctx.scale(this.backingScale, this.backingScale);\n        }\n        ctx.drawImage(\n            this.watermarkImage,\n            -this.watermarkImage.width / 2,\n            -this.watermarkImage.height / 2,\n        );\n        ctx.restore();\n    }\n\n    // Redraws the back buffer to the screen in its current state\n    // then draws the given shape translated and scaled on top of that.\n    // This is used for updating a shape while it is being drawn\n    // without doing a full repaint.\n    // The context is restored to its original state before returning.\n    drawShapeInProgress(shape) {\n        this.repaintLayer("main", false);\n        this.clipped(\n            () => {\n                this.transformed(\n                    () => {\n                        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_3__["renderShapeToContext"])(this.ctx, shape, {\n                            bufferCtx: this.bufferCtx,\n                            shouldOnlyDrawLatest: true,\n                        });\n                    },\n                    this.ctx,\n                    this.bufferCtx,\n                );\n            },\n            this.ctx,\n            this.bufferCtx,\n        );\n    }\n\n    // Draws the given shapes translated and scaled to the given context.\n    // The context is restored to its original state before returning.\n    draw(shapes, ctx, retryCallback) {\n        if (!shapes.length) {\n            return;\n        }\n        const drawShapes = () => {\n            shapes.map(shape =>\n                Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_3__["renderShapeToContext"])(ctx, shape, {retryCallback}),\n            );\n        };\n        this.clipped(() => this.transformed(drawShapes, ctx), ctx);\n    }\n\n    // Executes the given function after clipping the canvas to the image size.\n    // The context is restored to its original state before returning.\n    // This should not be called inside an @transformed block.\n    clipped(fn, ...contexts) {\n        const x = this.width === INFINITE ? 0 : this.position.x;\n        const y = this.height === INFINITE ? 0 : this.position.y;\n        const width =\n            this.width === INFINITE\n                ? this.canvas.width\n                : this.width * this.getRenderScale();\n        const height =\n            this.height === INFINITE\n                ? this.canvas.height\n                : this.height * this.getRenderScale();\n\n        for (var ctx of contexts) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(x, y, width, height);\n            ctx.clip();\n        }\n\n        fn();\n\n        for (ctx of contexts) {\n            ctx.restore();\n        }\n    }\n\n    // Executes the given function after translating and scaling the context.\n    // The context is restored to its original state before returning.\n    transformed(fn, ...contexts) {\n        for (var ctx of contexts) {\n            ctx.save();\n            ctx.translate(\n                Math.floor(this.position.x),\n                Math.floor(this.position.y),\n            );\n            const scale = this.getRenderScale();\n            ctx.scale(scale, scale);\n        }\n\n        fn();\n\n        for (ctx of contexts) {\n            ctx.restore();\n        }\n    }\n\n    clear(triggerClearEvent) {\n        if (triggerClearEvent == null) {\n            triggerClearEvent = true;\n        }\n        const oldShapes = this.shapes;\n        const newShapes = [];\n        this.setShapesInProgress([]);\n        this.execute(new _actions__WEBPACK_IMPORTED_MODULE_0__["ClearAction"](this, oldShapes, newShapes));\n        this.repaintLayer("main");\n        if (triggerClearEvent) {\n            this.trigger("clear", null);\n        }\n        this.trigger("drawingChange", {});\n    }\n\n    execute(action) {\n        this.undoStack.push(action);\n        action.do();\n        this.redoStack = [];\n    }\n\n    undo() {\n        if (!this.undoStack.length) {\n            return;\n        }\n        const action = this.undoStack.pop();\n        action.undo();\n        this.redoStack.push(action);\n        this.trigger("undo", {action});\n        this.trigger("drawingChange", {});\n    }\n\n    redo() {\n        if (!this.redoStack.length) {\n            return;\n        }\n        const action = this.redoStack.pop();\n        this.undoStack.push(action);\n        action.do();\n        this.trigger("redo", {action});\n        this.trigger("drawingChange", {});\n    }\n\n    canUndo() {\n        return !!this.undoStack.length;\n    }\n    canRedo() {\n        return !!this.redoStack.length;\n    }\n\n    getPixel(x, y) {\n        const p = this.drawingCoordsToClientCoords(x, y);\n        const pixel = this.ctx.getImageData(p.x, p.y, 1, 1).data;\n        if (pixel[3]) {\n            return `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;\n        } else {\n            return null;\n        }\n    }\n\n    getContentBounds() {\n        return Object(_util__WEBPACK_IMPORTED_MODULE_7__["getBoundingRect"])(\n            this.shapes\n                .concat(this.backgroundShapes)\n                .map(s => s.getBoundingRect()),\n            this.width === INFINITE ? 0 : this.width,\n            this.height === INFINITE ? 0 : this.height,\n        );\n    }\n\n    getDefaultImageRect(explicitSize, margin) {\n        if (explicitSize == null) {\n            explicitSize = {width: 0, height: 0};\n        }\n        if (margin == null) {\n            margin = {top: 0, right: 0, bottom: 0, left: 0};\n        }\n        return Object(_util__WEBPACK_IMPORTED_MODULE_7__["getDefaultImageRect"])(\n            this.shapes\n                .concat(this.backgroundShapes)\n                .map(s => s.getBoundingRect(this.ctx)),\n            explicitSize,\n            margin,\n        );\n    }\n\n    getImage(opts) {\n        if (opts == null) {\n            opts = {};\n        }\n        if (opts.includeWatermark == null) {\n            opts.includeWatermark = true;\n        }\n        if (opts.scaleDownRetina == null) {\n            opts.scaleDownRetina = true;\n        }\n        if (opts.scale == null) {\n            opts.scale = 1;\n        }\n        if (!opts.scaleDownRetina) {\n            opts.scale *= this.backingScale;\n        }\n\n        if (opts.includeWatermark) {\n            opts.watermarkImage = this.watermarkImage;\n            opts.watermarkScale = this.watermarkScale;\n            if (!opts.scaleDownRetina) {\n                opts.watermarkScale *= this.backingScale;\n            }\n        }\n        return Object(_renderSnapshotToImage__WEBPACK_IMPORTED_MODULE_5__["default"])(this.getSnapshot(), opts);\n    }\n\n    canvasForExport() {\n        this.repaintAllLayers();\n        return Object(_util__WEBPACK_IMPORTED_MODULE_7__["combineCanvases"])(this.backgroundCanvas, this.canvas);\n    }\n\n    canvasWithBackground(backgroundImageOrCanvas) {\n        return Object(_util__WEBPACK_IMPORTED_MODULE_7__["combineCanvases"])(backgroundImageOrCanvas, this.canvasForExport());\n    }\n\n    getSnapshot(keys = null) {\n        if (keys == null) {\n            keys = [\n                "shapes",\n                "imageSize",\n                "colors",\n                "position",\n                "scale",\n                "backgroundShapes",\n            ];\n        }\n        const snapshot = {};\n        for (let k of ["colors", "position", "scale"]) {\n            if (keys.indexOf(k) >= 0) {\n                snapshot[k] = this[k];\n            }\n        }\n        if (keys.indexOf("shapes") >= 0) {\n            snapshot.shapes = this.shapes.map(shape => Object(_shapes__WEBPACK_IMPORTED_MODULE_2__["shapeToJSON"])(shape));\n        }\n        if (keys.indexOf("backgroundShapes") >= 0) {\n            snapshot.backgroundShapes = this.backgroundShapes.map(shape =>\n                Object(_shapes__WEBPACK_IMPORTED_MODULE_2__["shapeToJSON"])(shape),\n            );\n        }\n        if (keys.indexOf("imageSize") >= 0) {\n            snapshot.imageSize = {width: this.width, height: this.height};\n        }\n\n        return snapshot;\n    }\n    getSnapshotJSON() {\n        console.warn(\n            "lc.getSnapshotJSON() is deprecated. use JSON.stringify(lc.getSnapshot()) instead.",\n        );\n        return JSON.stringify(this.getSnapshot());\n    }\n\n    getSVGString(opts) {\n        if (opts == null) {\n            opts = {};\n        }\n        return Object(_renderSnapshotToSVG__WEBPACK_IMPORTED_MODULE_6__["default"])(this.getSnapshot(), opts);\n    }\n\n    loadSnapshot(snapshot) {\n        if (!snapshot) {\n            return;\n        }\n\n        if (snapshot.colors) {\n            for (let k of ["primary", "secondary", "background"]) {\n                this.setColor(k, snapshot.colors[k]);\n            }\n        }\n\n        if (snapshot.shapes) {\n            // reset shapes\n            this.shapes = [];\n            // reset undostack aswell when loading a snapshot\n            this.undostack = [];\n\n            for (let shapeRepr of snapshot.shapes) {\n                const shape = Object(_shapes__WEBPACK_IMPORTED_MODULE_2__["JSONToShape"])(shapeRepr);\n                if (shape) {\n                    this.execute(new _actions__WEBPACK_IMPORTED_MODULE_0__["AddShapeAction"](this, shape));\n                }\n            }\n        }\n\n        if (snapshot.backgroundShapes) {\n            this.backgroundShapes = snapshot.backgroundShapes.map(s =>\n                Object(_shapes__WEBPACK_IMPORTED_MODULE_2__["JSONToShape"])(s),\n            );\n        }\n\n        if (snapshot.imageSize) {\n            this.width = snapshot.imageSize.width;\n            this.height = snapshot.imageSize.height;\n        }\n\n        if (snapshot.position) {\n            this.position = snapshot.position;\n        }\n        if (snapshot.scale) {\n            this.scale = snapshot.scale;\n        }\n\n        this.repaintAllLayers();\n        this.trigger("snapshotLoad");\n        this.trigger("drawingChange", {});\n    }\n\n    loadSnapshotJSON(str) {\n        console.warn(\n            "lc.loadSnapshotJSON() is deprecated. use lc.loadSnapshot(JSON.parse(snapshot)) instead.",\n        );\n        this.loadSnapshot(JSON.parse(str));\n    }\n}\n\nLiterallyCanvas.defaultOptions = _defaultOptions__WEBPACK_IMPORTED_MODULE_4__["default"];\n\n/* harmony default export */ __webpack_exports__["default"] = (LiterallyCanvas);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvTGl0ZXJhbGx5Q2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL0xpdGVyYWxseUNhbnZhcy5qcz8xNTBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IGJpbmRFdmVudHMgZnJvbSBcIi4vYmluZEV2ZW50c1wiO1xuaW1wb3J0IHtKU09OVG9TaGFwZSwgc2hhcGVUb0pTT059IGZyb20gXCIuL3NoYXBlc1wiO1xuaW1wb3J0IHtyZW5kZXJTaGFwZVRvQ29udGV4dH0gZnJvbSBcIi4vY2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCBkZWZhdWx0T3B0aW9ucyBmcm9tIFwiLi9kZWZhdWx0T3B0aW9uc1wiO1xuaW1wb3J0IHJlbmRlclNuYXBzaG90VG9JbWFnZSBmcm9tIFwiLi9yZW5kZXJTbmFwc2hvdFRvSW1hZ2VcIjtcbmltcG9ydCByZW5kZXJTbmFwc2hvdFRvU1ZHIGZyb20gXCIuL3JlbmRlclNuYXBzaG90VG9TVkdcIjtcbmltcG9ydCB7XG4gICAgZ2V0QmFja2luZ1NjYWxlLFxuICAgIG1hdGNoRWxlbWVudFNpemUsXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgIGFkZEltYWdlT25sb2FkLFxuICAgIGdldEJvdW5kaW5nUmVjdCxcbiAgICBnZXREZWZhdWx0SW1hZ2VSZWN0LFxuICAgIGNvbWJpbmVDYW52YXNlcyxcbn0gZnJvbSBcIi4vdXRpbFwiO1xuXG5jb25zdCBJTkZJTklURSA9IFwiaW5maW5pdGVcIjtcblxuY2xhc3MgTGl0ZXJhbGx5Q2FudmFzIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyKSB7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VTaXplID0gdGhpcy5zZXRJbWFnZVNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgbGV0IG9wdHMgPSBudWxsO1xuICAgICAgICBsZXQgY29udGFpbmVyRWwgPSBudWxsO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJFbCA9IGFyZzE7XG4gICAgICAgICAgICBvcHRzID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSBhcmcxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIHpvb21NaW46IG9wdHMuem9vbU1pbiB8fCAwLjIsXG4gICAgICAgICAgICB6b29tTWF4OiBvcHRzLnpvb21NYXggfHwgNC4wLFxuICAgICAgICAgICAgem9vbVN0ZXA6IG9wdHMuem9vbVN0ZXAgfHwgMC4yLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29sb3JzID0ge1xuICAgICAgICAgICAgcHJpbWFyeTogb3B0cy5wcmltYXJ5Q29sb3IgfHwgXCIjMDAwXCIsXG4gICAgICAgICAgICBzZWNvbmRhcnk6IG9wdHMuc2Vjb25kYXJ5Q29sb3IgfHwgXCIjZmZmXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBvcHRzLmJhY2tncm91bmRDb2xvciB8fCBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53YXRlcm1hcmtJbWFnZSA9IG9wdHMud2F0ZXJtYXJrSW1hZ2U7XG4gICAgICAgIHRoaXMud2F0ZXJtYXJrU2NhbGUgPSBvcHRzLndhdGVybWFya1NjYWxlIHx8IDE7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ3R4ID0gdGhpcy5iYWNrZ3JvdW5kQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwidHJhbnNwYXJlbnRcIjtcblxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMuYnVmZmVyQ3R4ID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHRoaXMuYmFja2luZ1NjYWxlID0gZ2V0QmFja2luZ1NjYWxlKHRoaXMuY3R4KTtcblxuICAgICAgICB0aGlzLmJhY2tncm91bmRTaGFwZXMgPSBvcHRzLmJhY2tncm91bmRTaGFwZXMgfHwgW107XG4gICAgICAgIHRoaXMuX3NoYXBlc0luUHJvZ3Jlc3MgPSBbXTtcbiAgICAgICAgdGhpcy5zaGFwZXMgPSBbXTtcbiAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcblxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt4OiAwLCB5OiAwfTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IDEuMDtcbiAgICAgICAgLy8gR1VJIGltbWVkaWF0ZWx5IHJlcGxhY2VzIHRoaXMgdmFsdWUsIGJ1dCBpdCdzIGluaXRpYWxpemVkIHNvIHlvdSBjYW4gaGF2ZVxuICAgICAgICAvLyBzb21ldGhpbmcgcmVhbGx5IHNpbXBsZVxuICAgICAgICB0aGlzLnNldFRvb2wobmV3IHRoaXMub3B0cy50b29sc1swXSh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdHMuaW1hZ2VTaXplLndpZHRoIHx8IElORklOSVRFO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaW1hZ2VTaXplLmhlaWdodCB8fCBJTkZJTklURTtcblxuICAgICAgICAvLyBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgd2UgYXJlIHpvb21lZCB0byBAc2NhbGUsIHBhbm5lZCB0byBAcG9zaXRpb24sIGFuZFxuICAgICAgICAvLyB0aGF0IGFsbCBsYXllcnMgYXJlIHJlcGFpbnRlZC5cbiAgICAgICAgdGhpcy5zZXRab29tKHRoaXMuc2NhbGUpO1xuXG4gICAgICAgIGlmIChvcHRzLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTbmFwc2hvdChvcHRzLnNuYXBzaG90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNCb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGFpbmVyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvRWxlbWVudChjb250YWluZXJFbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc3BvbmRUb1NpemVDaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cblxuICAgIGJpbmRUb0VsZW1lbnQoY29udGFpbmVyRWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyRWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIlRyeWluZyB0byBiaW5kIExpdGVyYWxseSBDYW52YXMgdG8gYSBET00gZWxlbWVudCBtb3JlIHRoYW4gb25jZSBpcyB1bnN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlRXZlbnRzID0gYmluZEV2ZW50cyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLFxuICAgICAgICAgICAgdGhpcy5vcHRzLmtleWJvYXJkU2hvcnRjdXRzLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnN0eWxlW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IHRoaXMuY29sb3JzLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodGhpcy5iYWNrZ3JvdW5kQ2FudmFzKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cbiAgICAgICAgdGhpcy5pc0JvdW5kID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCByZXBhaW50QWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5rZWVwUGFuSW5JbWFnZUJvdW5kcygpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50QWxsTGF5ZXJzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNwb25kVG9TaXplQ2hhbmdlID0gbWF0Y2hFbGVtZW50U2l6ZShcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwsXG4gICAgICAgICAgICBbdGhpcy5iYWNrZ3JvdW5kQ2FudmFzLCB0aGlzLmNhbnZhc10sXG4gICAgICAgICAgICB0aGlzLmJhY2tpbmdTY2FsZSxcbiAgICAgICAgICAgIHJlcGFpbnRBbGwsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMud2F0ZXJtYXJrSW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMud2F0ZXJtYXJrSW1hZ2Uub25sb2FkID0gKCkgPT4gdGhpcy5yZXBhaW50TGF5ZXIoXCJiYWNrZ3JvdW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9vbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2wuZGlkQmVjb21lQWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwYWludEFsbCgpO1xuICAgIH1cblxuICAgIF90ZWFyZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9vbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2wud2lsbEJlY29tZUluYWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5zdWJzY3JpYmVFdmVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2wgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvdW5kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJpZ2dlcihuYW1lLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtkZXRhaWw6IGRhdGF9KSk7XG4gICAgICAgIC8vIGRpc3BhdGNoRXZlbnQgaGFzIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGRvZXNuJ3QgbWVhbiBhbnl0aGluZyB0byB1cywgc29cbiAgICAgICAgLy8gZG9uJ3QgbGV0IENvZmZlZVNjcmlwdCBzZW5kIGl0IGJhY2tcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgb24obmFtZSwgZm4pIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGUgPT4gZm4oZS5kZXRhaWwpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwcGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBhY3R1YWwgcmF0aW8gb2YgZHJhd2luZy1zcGFjZSBwaXhlbHMgdG8gcGVyY2VpdmVkIHBpeGVscywgYWNjb3VudGluZyBmb3JcbiAgICAvLyBib3RoIHpvb20gYW5kIGRpc3BsYXlQaXhlbFdpZHRoLiB1c2UgdGhpcyB3aGVuIGNvbnZlcnRpbmcgYmV0d2VlblxuICAgIC8vIGRyYXdpbmctc3BhY2UgYW5kIHNjcmVlbi1zcGFjZS5cbiAgICBnZXRSZW5kZXJTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUgKiB0aGlzLmJhY2tpbmdTY2FsZTtcbiAgICB9XG5cbiAgICBjbGllbnRDb29yZHNUb0RyYXdpbmdDb29yZHMoeCwgeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDpcbiAgICAgICAgICAgICAgICAoeCAqIHRoaXMuYmFja2luZ1NjYWxlIC0gdGhpcy5wb3NpdGlvbi54KSAvXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJTY2FsZSgpLFxuICAgICAgICAgICAgeTpcbiAgICAgICAgICAgICAgICAoeSAqIHRoaXMuYmFja2luZ1NjYWxlIC0gdGhpcy5wb3NpdGlvbi55KSAvXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJTY2FsZSgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGRyYXdpbmdDb29yZHNUb0NsaWVudENvb3Jkcyh4LCB5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICogdGhpcy5nZXRSZW5kZXJTY2FsZSgpICsgdGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogeSAqIHRoaXMuZ2V0UmVuZGVyU2NhbGUoKSArIHRoaXMucG9zaXRpb24ueSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRJbWFnZVNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgSU5GSU5JVEU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IElORklOSVRFO1xuICAgICAgICB0aGlzLmtlZXBQYW5JbkltYWdlQm91bmRzKCk7XG4gICAgICAgIHRoaXMucmVwYWludEFsbExheWVycygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJpbWFnZVNpemVDaGFuZ2VcIiwge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRUb29sKHRvb2wpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9vbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sLndpbGxCZWNvbWVJbmFjdGl2ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2wgPSB0b29sO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJ0b29sQ2hhbmdlXCIsIHt0b29sfSk7XG4gICAgICAgIGlmICh0aGlzLmlzQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbC5kaWRCZWNvbWVBY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTaGFwZXNJblByb2dyZXNzKG5ld1ZhbCkge1xuICAgICAgICB0aGlzLl9zaGFwZXNJblByb2dyZXNzID0gbmV3VmFsO1xuICAgIH1cblxuICAgIHBvaW50ZXJEb3duKHgsIHkpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuY2xpZW50Q29vcmRzVG9EcmF3aW5nQ29vcmRzKHgsIHkpO1xuICAgICAgICBpZiAodGhpcy50b29sLnVzZXNTaW1wbGVBUEkpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbC5iZWdpbihwLngsIHAueSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJhd1N0YXJ0XCIsIHt0b29sOiB0aGlzLnRvb2x9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJsYy1wb2ludGVyZG93blwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbDogdGhpcy50b29sLFxuICAgICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgICB5OiBwLnksXG4gICAgICAgICAgICAgICAgcmF3WDogeCxcbiAgICAgICAgICAgICAgICByYXdZOiB5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwb2ludGVyTW92ZSh4LCB5KSB7XG4gICAgICAgIC8vIEZJWE1FOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcmV0dXJucyBhIHZhbHVlIHRvIGJlIHVzZWQgaW4gb3JkZXIgdG9cbiAgICAgICAgLy8gY2FuY2VsIGFuaW1hdGlvbkZyYW1lIHdoZW4gaXQgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkLi4uXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5jbGllbnRDb29yZHNUb0RyYXdpbmdDb29yZHMoeCwgeSk7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sICE9IG51bGwgPyB0aGlzLnRvb2wudXNlc1NpbXBsZUFQSSA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sLmNvbnRpbnVlKHAueCwgcC55LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJhd0NvbnRpbnVlXCIsIHt0b29sOiB0aGlzLnRvb2x9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwibGMtcG9pbnRlcmRyYWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbDogdGhpcy50b29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogcC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3WDogeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1k6IHksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImxjLXBvaW50ZXJtb3ZlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IHRoaXMudG9vbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHAueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1g6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdZOiB5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBvaW50ZXJVcCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmNsaWVudENvb3Jkc1RvRHJhd2luZ0Nvb3Jkcyh4LCB5KTtcbiAgICAgICAgaWYgKHRoaXMudG9vbC51c2VzU2ltcGxlQVBJKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sLmVuZChwLngsIHAueSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJhd0VuZFwiLCB7dG9vbDogdGhpcy50b29sfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImxjLXBvaW50ZXJ1cFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbDogdGhpcy50b29sLFxuICAgICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgICB5OiBwLnksXG4gICAgICAgICAgICAgICAgcmF3WDogeCxcbiAgICAgICAgICAgICAgICByYXdZOiB5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb2xvcihuYW1lLCBjb2xvcikge1xuICAgICAgICB0aGlzLmNvbG9yc1tuYW1lXSA9IGNvbG9yO1xuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImJhY2tncm91bmRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3JzLmJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBhaW50TGF5ZXIoXCJiYWNrZ3JvdW5kXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInByaW1hcnlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnRMYXllcihcIm1haW5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2Vjb25kYXJ5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBhaW50TGF5ZXIoXCJtYWluXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcihgJHtuYW1lfUNvbG9yQ2hhbmdlYCwgdGhpcy5jb2xvcnNbbmFtZV0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImRyYXdpbmdDaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb2xvcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1tuYW1lXTtcbiAgICB9XG5cbiAgICBzYXZlU2hhcGUoc2hhcGUsIHRyaWdnZXJTaGFwZVNhdmVFdmVudCwgcHJldmlvdXNTaGFwZUlkID0gbnVsbCkge1xuICAgICAgICBpZiAodHJpZ2dlclNoYXBlU2F2ZUV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyaWdnZXJTaGFwZVNhdmVFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2aW91c1NoYXBlSWQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2hhcGVJZCA9IHRoaXMuc2hhcGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gdGhpcy5zaGFwZXNbdGhpcy5zaGFwZXMubGVuZ3RoIC0gMV0uaWRcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leGVjdXRlKG5ldyBhY3Rpb25zLkFkZFNoYXBlQWN0aW9uKHRoaXMsIHNoYXBlLCBwcmV2aW91c1NoYXBlSWQpKTtcbiAgICAgICAgaWYgKHRyaWdnZXJTaGFwZVNhdmVFdmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwic2hhcGVTYXZlXCIsIHtzaGFwZSwgcHJldmlvdXNTaGFwZUlkfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJhd2luZ0NoYW5nZVwiKTtcbiAgICB9XG5cbiAgICBwYW4oeCwgeSkge1xuICAgICAgICAvLyBTdWJ0cmFjdCBiZWNhdXNlIHdlIGFyZSBtb3ZpbmcgdGhlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMuc2V0UGFuKHRoaXMucG9zaXRpb24ueCAtIHgsIHRoaXMucG9zaXRpb24ueSAtIHkpO1xuICAgIH1cblxuICAgIGtlZXBQYW5JbkltYWdlQm91bmRzKCkge1xuICAgICAgICBjb25zdCByZW5kZXJTY2FsZSA9IHRoaXMuZ2V0UmVuZGVyU2NhbGUoKTtcbiAgICAgICAgbGV0IHt4LCB5fSA9IHRoaXMucG9zaXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IElORklOSVRFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggPiB0aGlzLndpZHRoICogcmVuZGVyU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB4ID0gKHRoaXMuY2FudmFzLndpZHRoIC0gdGhpcy53aWR0aCAqIHJlbmRlclNjYWxlKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMCwgeCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoIC0gdGhpcy53aWR0aCAqIHJlbmRlclNjYWxlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IElORklOSVRFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMuaGVpZ2h0ID4gdGhpcy5oZWlnaHQgKiByZW5kZXJTY2FsZSkge1xuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5jYW52YXMuaGVpZ2h0IC0gdGhpcy5oZWlnaHQgKiByZW5kZXJTY2FsZSkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDAsIHkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgLSB0aGlzLmhlaWdodCAqIHJlbmRlclNjYWxlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge3gsIHl9O1xuICAgIH1cblxuICAgIHNldFBhbih4LCB5KSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB7eCwgeX07XG4gICAgICAgIHRoaXMua2VlcFBhbkluSW1hZ2VCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50QWxsTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInBhblwiLCB7eDogdGhpcy5wb3NpdGlvbi54LCB5OiB0aGlzLnBvc2l0aW9uLnl9KTtcbiAgICB9XG5cbiAgICB6b29tKGZhY3Rvcikge1xuICAgICAgICBsZXQgbmV3U2NhbGUgPSB0aGlzLnNjYWxlICsgZmFjdG9yO1xuICAgICAgICBuZXdTY2FsZSA9IE1hdGgubWF4KG5ld1NjYWxlLCB0aGlzLmNvbmZpZy56b29tTWluKTtcbiAgICAgICAgbmV3U2NhbGUgPSBNYXRoLm1pbihuZXdTY2FsZSwgdGhpcy5jb25maWcuem9vbU1heCk7XG4gICAgICAgIG5ld1NjYWxlID0gTWF0aC5yb3VuZChuZXdTY2FsZSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIHRoaXMuc2V0Wm9vbShuZXdTY2FsZSk7XG4gICAgfVxuXG4gICAgc2V0Wm9vbShzY2FsZSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmNsaWVudENvb3Jkc1RvRHJhd2luZ0Nvb3JkcyhcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoIC8gMixcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCAvIDIsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9sZFNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9XG4gICAgICAgICAgICAodGhpcy5jYW52YXMud2lkdGggLyAyKSAqIHRoaXMuYmFja2luZ1NjYWxlIC1cbiAgICAgICAgICAgIGNlbnRlci54ICogdGhpcy5nZXRSZW5kZXJTY2FsZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPVxuICAgICAgICAgICAgKHRoaXMuY2FudmFzLmhlaWdodCAvIDIpICogdGhpcy5iYWNraW5nU2NhbGUgLVxuICAgICAgICAgICAgY2VudGVyLnkgKiB0aGlzLmdldFJlbmRlclNjYWxlKCk7XG5cbiAgICAgICAgdGhpcy5rZWVwUGFuSW5JbWFnZUJvdW5kcygpO1xuXG4gICAgICAgIHRoaXMucmVwYWludEFsbExheWVycygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJ6b29tXCIsIHtvbGRTY2FsZSwgbmV3U2NhbGU6IHRoaXMuc2NhbGV9KTtcbiAgICB9XG5cbiAgICBzZXRXYXRlcm1hcmtJbWFnZShuZXdJbWFnZSkge1xuICAgICAgICB0aGlzLndhdGVybWFya0ltYWdlID0gbmV3SW1hZ2U7XG4gICAgICAgIGFkZEltYWdlT25sb2FkKG5ld0ltYWdlLCAoKSA9PiB0aGlzLnJlcGFpbnRMYXllcihcImJhY2tncm91bmRcIikpO1xuICAgICAgICBpZiAobmV3SW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludExheWVyKFwiYmFja2dyb3VuZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcGFpbnRBbGxMYXllcnMoKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiBbXCJiYWNrZ3JvdW5kXCIsIFwibWFpblwiXSkge1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50TGF5ZXIoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXBhaW50cyB0aGUgY2FudmFzLlxuICAgIC8vIElmIGRpcnR5IGlzIHRydWUgdGhlbiBhbGwgc2F2ZWQgc2hhcGVzIGFyZSBjb21wbGV0ZWx5IHJlZHJhd24sXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSBiYWNrIGJ1ZmZlciBpcyBzaW1wbHkgY29waWVkIHRvIHRoZSBzY3JlZW4gYXMgaXMuXG4gICAgcmVwYWludExheWVyKHJlcGFpbnRMYXllcktleSwgZGlydHkpIHtcbiAgICAgICAgaWYgKGRpcnR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGRpcnR5ID0gcmVwYWludExheWVyS2V5ID09PSBcIm1haW5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocmVwYWludExheWVyS2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiYmFja2dyb3VuZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEN0eC5jbGVhclJlY3QoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciByZXRyeUNhbGxiYWNrID0gKCkgPT4gdGhpcy5yZXBhaW50TGF5ZXIoXCJiYWNrZ3JvdW5kXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLndhdGVybWFya0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcldhdGVybWFyayhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZFNoYXBlcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ3R4LFxuICAgICAgICAgICAgICAgICAgICByZXRyeUNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWFpblwiOlxuICAgICAgICAgICAgICAgIHJldHJ5Q2FsbGJhY2sgPSAoKSA9PiB0aGlzLnJlcGFpbnRMYXllcihcIm1haW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJDdHguY2xlYXJSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KHRoaXMuc2hhcGVzLCB0aGlzLmJ1ZmZlckN0eCwgcmV0cnlDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggPiAwICYmIHRoaXMuY2FudmFzLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gXCIjY2NjXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwcGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmJ1ZmZlciwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuY3R4KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hhcGVzSW5Qcm9ncmVzcy5tYXAoc2hhcGUgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTaGFwZVRvQ29udGV4dCh0aGlzLmN0eCwgc2hhcGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQ3R4OiB0aGlzLmJ1ZmZlckN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT25seURyYXdMYXRlc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJDdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyQ3R4LFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcihcInJlcGFpbnRcIiwge2xheWVyS2V5OiByZXBhaW50TGF5ZXJLZXl9KTtcbiAgICB9XG5cbiAgICBfcmVuZGVyV2F0ZXJtYXJrKGN0eCwgd29ycnlBYm91dFJldGluYSwgcmV0cnlDYWxsYmFjaykge1xuICAgICAgICBpZiAod29ycnlBYm91dFJldGluYSA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JyeUFib3V0UmV0aW5hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMud2F0ZXJtYXJrSW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMud2F0ZXJtYXJrSW1hZ2Uub25sb2FkID0gcmV0cnlDYWxsYmFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3R4LmNhbnZhcy53aWR0aCAvIDIsIGN0eC5jYW52YXMuaGVpZ2h0IC8gMik7XG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLndhdGVybWFya1NjYWxlLCB0aGlzLndhdGVybWFya1NjYWxlKTtcbiAgICAgICAgaWYgKHdvcnJ5QWJvdXRSZXRpbmEpIHtcbiAgICAgICAgICAgIGN0eC5zY2FsZSh0aGlzLmJhY2tpbmdTY2FsZSwgdGhpcy5iYWNraW5nU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICB0aGlzLndhdGVybWFya0ltYWdlLFxuICAgICAgICAgICAgLXRoaXMud2F0ZXJtYXJrSW1hZ2Uud2lkdGggLyAyLFxuICAgICAgICAgICAgLXRoaXMud2F0ZXJtYXJrSW1hZ2UuaGVpZ2h0IC8gMixcbiAgICAgICAgKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvLyBSZWRyYXdzIHRoZSBiYWNrIGJ1ZmZlciB0byB0aGUgc2NyZWVuIGluIGl0cyBjdXJyZW50IHN0YXRlXG4gICAgLy8gdGhlbiBkcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdHJhbnNsYXRlZCBhbmQgc2NhbGVkIG9uIHRvcCBvZiB0aGF0LlxuICAgIC8vIFRoaXMgaXMgdXNlZCBmb3IgdXBkYXRpbmcgYSBzaGFwZSB3aGlsZSBpdCBpcyBiZWluZyBkcmF3blxuICAgIC8vIHdpdGhvdXQgZG9pbmcgYSBmdWxsIHJlcGFpbnQuXG4gICAgLy8gVGhlIGNvbnRleHQgaXMgcmVzdG9yZWQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgZHJhd1NoYXBlSW5Qcm9ncmVzcyhzaGFwZSkge1xuICAgICAgICB0aGlzLnJlcGFpbnRMYXllcihcIm1haW5cIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNsaXBwZWQoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU2hhcGVUb0NvbnRleHQodGhpcy5jdHgsIHNoYXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQ3R4OiB0aGlzLmJ1ZmZlckN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPbmx5RHJhd0xhdGVzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJDdHgsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmN0eCxcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQ3R4LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIERyYXdzIHRoZSBnaXZlbiBzaGFwZXMgdHJhbnNsYXRlZCBhbmQgc2NhbGVkIHRvIHRoZSBnaXZlbiBjb250ZXh0LlxuICAgIC8vIFRoZSBjb250ZXh0IGlzIHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgIGRyYXcoc2hhcGVzLCBjdHgsIHJldHJ5Q2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFzaGFwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJhd1NoYXBlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHNoYXBlcy5tYXAoc2hhcGUgPT5cbiAgICAgICAgICAgICAgICByZW5kZXJTaGFwZVRvQ29udGV4dChjdHgsIHNoYXBlLCB7cmV0cnlDYWxsYmFja30pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGlwcGVkKCgpID0+IHRoaXMudHJhbnNmb3JtZWQoZHJhd1NoYXBlcywgY3R4KSwgY3R4KTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYWZ0ZXIgY2xpcHBpbmcgdGhlIGNhbnZhcyB0byB0aGUgaW1hZ2Ugc2l6ZS5cbiAgICAvLyBUaGUgY29udGV4dCBpcyByZXN0b3JlZCB0byBpdHMgb3JpZ2luYWwgc3RhdGUgYmVmb3JlIHJldHVybmluZy5cbiAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGluc2lkZSBhbiBAdHJhbnNmb3JtZWQgYmxvY2suXG4gICAgY2xpcHBlZChmbiwgLi4uY29udGV4dHMpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMud2lkdGggPT09IElORklOSVRFID8gMCA6IHRoaXMucG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuaGVpZ2h0ID09PSBJTkZJTklURSA/IDAgOiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgICAgIGNvbnN0IHdpZHRoID1cbiAgICAgICAgICAgIHRoaXMud2lkdGggPT09IElORklOSVRFXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNhbnZhcy53aWR0aFxuICAgICAgICAgICAgICAgIDogdGhpcy53aWR0aCAqIHRoaXMuZ2V0UmVuZGVyU2NhbGUoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID09PSBJTkZJTklURVxuICAgICAgICAgICAgICAgID8gdGhpcy5jYW52YXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiB0aGlzLmhlaWdodCAqIHRoaXMuZ2V0UmVuZGVyU2NhbGUoKTtcblxuICAgICAgICBmb3IgKHZhciBjdHggb2YgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmbigpO1xuXG4gICAgICAgIGZvciAoY3R4IG9mIGNvbnRleHRzKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIGFmdGVyIHRyYW5zbGF0aW5nIGFuZCBzY2FsaW5nIHRoZSBjb250ZXh0LlxuICAgIC8vIFRoZSBjb250ZXh0IGlzIHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgIHRyYW5zZm9ybWVkKGZuLCAuLi5jb250ZXh0cykge1xuICAgICAgICBmb3IgKHZhciBjdHggb2YgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IodGhpcy5wb3NpdGlvbi54KSxcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHRoaXMucG9zaXRpb24ueSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFJlbmRlclNjYWxlKCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuKCk7XG5cbiAgICAgICAgZm9yIChjdHggb2YgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhcih0cmlnZ2VyQ2xlYXJFdmVudCkge1xuICAgICAgICBpZiAodHJpZ2dlckNsZWFyRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJpZ2dlckNsZWFyRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZFNoYXBlcyA9IHRoaXMuc2hhcGVzO1xuICAgICAgICBjb25zdCBuZXdTaGFwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXRTaGFwZXNJblByb2dyZXNzKFtdKTtcbiAgICAgICAgdGhpcy5leGVjdXRlKG5ldyBhY3Rpb25zLkNsZWFyQWN0aW9uKHRoaXMsIG9sZFNoYXBlcywgbmV3U2hhcGVzKSk7XG4gICAgICAgIHRoaXMucmVwYWludExheWVyKFwibWFpblwiKTtcbiAgICAgICAgaWYgKHRyaWdnZXJDbGVhckV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJjbGVhclwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoXCJkcmF3aW5nQ2hhbmdlXCIsIHt9KTtcbiAgICB9XG5cbiAgICBleGVjdXRlKGFjdGlvbikge1xuICAgICAgICB0aGlzLnVuZG9TdGFjay5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFjdGlvbi5kbygpO1xuICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHVuZG8oKSB7XG4gICAgICAgIGlmICghdGhpcy51bmRvU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy51bmRvU3RhY2sucG9wKCk7XG4gICAgICAgIGFjdGlvbi51bmRvKCk7XG4gICAgICAgIHRoaXMucmVkb1N0YWNrLnB1c2goYWN0aW9uKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwidW5kb1wiLCB7YWN0aW9ufSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcImRyYXdpbmdDaGFuZ2VcIiwge30pO1xuICAgIH1cblxuICAgIHJlZG8oKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWRvU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5yZWRvU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudW5kb1N0YWNrLnB1c2goYWN0aW9uKTtcbiAgICAgICAgYWN0aW9uLmRvKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInJlZG9cIiwge2FjdGlvbn0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJkcmF3aW5nQ2hhbmdlXCIsIHt9KTtcbiAgICB9XG5cbiAgICBjYW5VbmRvKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnVuZG9TdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIGNhblJlZG8oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVkb1N0YWNrLmxlbmd0aDtcbiAgICB9XG5cbiAgICBnZXRQaXhlbCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmRyYXdpbmdDb29yZHNUb0NsaWVudENvb3Jkcyh4LCB5KTtcbiAgICAgICAgY29uc3QgcGl4ZWwgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEocC54LCBwLnksIDEsIDEpLmRhdGE7XG4gICAgICAgIGlmIChwaXhlbFszXSkge1xuICAgICAgICAgICAgcmV0dXJuIGByZ2IoJHtwaXhlbFswXX0sICR7cGl4ZWxbMV19LCAke3BpeGVsWzJdfSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb250ZW50Qm91bmRzKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgdGhpcy5zaGFwZXNcbiAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuYmFja2dyb3VuZFNoYXBlcylcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gcy5nZXRCb3VuZGluZ1JlY3QoKSksXG4gICAgICAgICAgICB0aGlzLndpZHRoID09PSBJTkZJTklURSA/IDAgOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPT09IElORklOSVRFID8gMCA6IHRoaXMuaGVpZ2h0LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRJbWFnZVJlY3QoZXhwbGljaXRTaXplLCBtYXJnaW4pIHtcbiAgICAgICAgaWYgKGV4cGxpY2l0U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBleHBsaWNpdFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdEltYWdlUmVjdChcbiAgICAgICAgICAgIHRoaXMuc2hhcGVzXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmJhY2tncm91bmRTaGFwZXMpXG4gICAgICAgICAgICAgICAgLm1hcChzID0+IHMuZ2V0Qm91bmRpbmdSZWN0KHRoaXMuY3R4KSksXG4gICAgICAgICAgICBleHBsaWNpdFNpemUsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0SW1hZ2Uob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVdhdGVybWFyayA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRzLmluY2x1ZGVXYXRlcm1hcmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnNjYWxlRG93blJldGluYSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRzLnNjYWxlRG93blJldGluYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuc2NhbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5zY2FsZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLnNjYWxlRG93blJldGluYSkge1xuICAgICAgICAgICAgb3B0cy5zY2FsZSAqPSB0aGlzLmJhY2tpbmdTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVXYXRlcm1hcmspIHtcbiAgICAgICAgICAgIG9wdHMud2F0ZXJtYXJrSW1hZ2UgPSB0aGlzLndhdGVybWFya0ltYWdlO1xuICAgICAgICAgICAgb3B0cy53YXRlcm1hcmtTY2FsZSA9IHRoaXMud2F0ZXJtYXJrU2NhbGU7XG4gICAgICAgICAgICBpZiAoIW9wdHMuc2NhbGVEb3duUmV0aW5hKSB7XG4gICAgICAgICAgICAgICAgb3B0cy53YXRlcm1hcmtTY2FsZSAqPSB0aGlzLmJhY2tpbmdTY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyU25hcHNob3RUb0ltYWdlKHRoaXMuZ2V0U25hcHNob3QoKSwgb3B0cyk7XG4gICAgfVxuXG4gICAgY2FudmFzRm9yRXhwb3J0KCkge1xuICAgICAgICB0aGlzLnJlcGFpbnRBbGxMYXllcnMoKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDYW52YXNlcyh0aGlzLmJhY2tncm91bmRDYW52YXMsIHRoaXMuY2FudmFzKTtcbiAgICB9XG5cbiAgICBjYW52YXNXaXRoQmFja2dyb3VuZChiYWNrZ3JvdW5kSW1hZ2VPckNhbnZhcykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNhbnZhc2VzKGJhY2tncm91bmRJbWFnZU9yQ2FudmFzLCB0aGlzLmNhbnZhc0ZvckV4cG9ydCgpKTtcbiAgICB9XG5cbiAgICBnZXRTbmFwc2hvdChrZXlzID0gbnVsbCkge1xuICAgICAgICBpZiAoa2V5cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBrZXlzID0gW1xuICAgICAgICAgICAgICAgIFwic2hhcGVzXCIsXG4gICAgICAgICAgICAgICAgXCJpbWFnZVNpemVcIixcbiAgICAgICAgICAgICAgICBcImNvbG9yc1wiLFxuICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIixcbiAgICAgICAgICAgICAgICBcInNjYWxlXCIsXG4gICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kU2hhcGVzXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0ge307XG4gICAgICAgIGZvciAobGV0IGsgb2YgW1wiY29sb3JzXCIsIFwicG9zaXRpb25cIiwgXCJzY2FsZVwiXSkge1xuICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc25hcHNob3Rba10gPSB0aGlzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoXCJzaGFwZXNcIikgPj0gMCkge1xuICAgICAgICAgICAgc25hcHNob3Quc2hhcGVzID0gdGhpcy5zaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlVG9KU09OKHNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihcImJhY2tncm91bmRTaGFwZXNcIikgPj0gMCkge1xuICAgICAgICAgICAgc25hcHNob3QuYmFja2dyb3VuZFNoYXBlcyA9IHRoaXMuYmFja2dyb3VuZFNoYXBlcy5tYXAoc2hhcGUgPT5cbiAgICAgICAgICAgICAgICBzaGFwZVRvSlNPTihzaGFwZSksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoXCJpbWFnZVNpemVcIikgPj0gMCkge1xuICAgICAgICAgICAgc25hcHNob3QuaW1hZ2VTaXplID0ge3dpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICB9XG4gICAgZ2V0U25hcHNob3RKU09OKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcImxjLmdldFNuYXBzaG90SlNPTigpIGlzIGRlcHJlY2F0ZWQuIHVzZSBKU09OLnN0cmluZ2lmeShsYy5nZXRTbmFwc2hvdCgpKSBpbnN0ZWFkLlwiLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRTbmFwc2hvdCgpKTtcbiAgICB9XG5cbiAgICBnZXRTVkdTdHJpbmcob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlclNuYXBzaG90VG9TVkcodGhpcy5nZXRTbmFwc2hvdCgpLCBvcHRzKTtcbiAgICB9XG5cbiAgICBsb2FkU25hcHNob3Qoc25hcHNob3QpIHtcbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBzaG90LmNvbG9ycykge1xuICAgICAgICAgICAgZm9yIChsZXQgayBvZiBbXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCIsIFwiYmFja2dyb3VuZFwiXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29sb3Ioaywgc25hcHNob3QuY29sb3JzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwc2hvdC5zaGFwZXMpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHNoYXBlc1xuICAgICAgICAgICAgdGhpcy5zaGFwZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIHJlc2V0IHVuZG9zdGFjayBhc3dlbGwgd2hlbiBsb2FkaW5nIGEgc25hcHNob3RcbiAgICAgICAgICAgIHRoaXMudW5kb3N0YWNrID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IHNoYXBlUmVwciBvZiBzbmFwc2hvdC5zaGFwZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZSA9IEpTT05Ub1NoYXBlKHNoYXBlUmVwcik7XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZShuZXcgYWN0aW9ucy5BZGRTaGFwZUFjdGlvbih0aGlzLCBzaGFwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwc2hvdC5iYWNrZ3JvdW5kU2hhcGVzKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRTaGFwZXMgPSBzbmFwc2hvdC5iYWNrZ3JvdW5kU2hhcGVzLm1hcChzID0+XG4gICAgICAgICAgICAgICAgSlNPTlRvU2hhcGUocyksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBzaG90LmltYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNuYXBzaG90LmltYWdlU2l6ZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc25hcHNob3QuaW1hZ2VTaXplLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwc2hvdC5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHNuYXBzaG90LnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbmFwc2hvdC5zY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNuYXBzaG90LnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXBhaW50QWxsTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInNuYXBzaG90TG9hZFwiKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZHJhd2luZ0NoYW5nZVwiLCB7fSk7XG4gICAgfVxuXG4gICAgbG9hZFNuYXBzaG90SlNPTihzdHIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJsYy5sb2FkU25hcHNob3RKU09OKCkgaXMgZGVwcmVjYXRlZC4gdXNlIGxjLmxvYWRTbmFwc2hvdChKU09OLnBhcnNlKHNuYXBzaG90KSkgaW5zdGVhZC5cIixcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2FkU25hcHNob3QoSlNPTi5wYXJzZShzdHIpKTtcbiAgICB9XG59XG5cbkxpdGVyYWxseUNhbnZhcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBMaXRlcmFsbHlDYW52YXM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/LiterallyCanvas.js\n',
                );

                /***/
            },

        /***/ "./src/TextRenderer.js":
            /*!*****************************!*\
  !*** ./src/TextRenderer.js ***!
  \*****************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fontmetrics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fontmetrics.js */ "./src/fontmetrics.js");\n/* harmony import */ var _fontmetrics_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_fontmetrics_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst parseFontString = function(font) {\n    const fontItems = font.split(" ");\n\n    let fontSize = 0;\n\n    for (let item of fontItems) {\n        const maybeSize = parseInt(item.replace("px", ""), 10);\n        if (!isNaN(maybeSize)) {\n            fontSize = maybeSize;\n        }\n    }\n    if (!fontSize) {\n        throw "Font size not found";\n    }\n\n    const remainingFontString = font\n        .substring(fontItems[0].length + 1)\n        .replace("bold ", "")\n        .replace("italic ", "")\n        .replace("underline ", "");\n\n    const fontFamily = remainingFontString;\n\n    return {fontSize, fontFamily};\n};\n\nconst getNextLine = function(ctx, text, forcedWidth) {\n    if (!text.length) {\n        return ["", ""];\n    }\n\n    let endIndex = 0;\n    let lastGoodIndex = 0;\n    let lastOkayIndex = 0;\n    let wasInWord = false;\n\n    while (true) {\n        endIndex += 1;\n        const isEndOfString = endIndex >= text.length;\n\n        const isWhitespace = !isEndOfString && text[endIndex].match(/\\s/);\n        const isNonWord = isWhitespace || isEndOfString;\n\n        const textToHere = text.substring(0, endIndex);\n        const doesSubstringFit = forcedWidth\n            ? ctx.measureTextWidth(textToHere).width <= forcedWidth\n            : true;\n\n        if (doesSubstringFit) {\n            lastOkayIndex = endIndex;\n        }\n\n        // word -> non-word\n        if (isNonWord && wasInWord) {\n            wasInWord = false;\n            if (doesSubstringFit) {\n                lastGoodIndex = endIndex;\n            }\n        }\n\n        wasInWord = !isWhitespace;\n\n        if (isEndOfString || !doesSubstringFit) {\n            if (doesSubstringFit) {\n                return [text, ""];\n            } else if (lastGoodIndex > 0) {\n                let nextWordStartIndex = lastGoodIndex + 1;\n                while (\n                    nextWordStartIndex < text.length &&\n                    text[nextWordStartIndex].match(/\\s/)\n                ) {\n                    nextWordStartIndex += 1;\n                }\n                return [\n                    text.substring(0, lastGoodIndex),\n                    text.substring(nextWordStartIndex),\n                ];\n            } else {\n                return [\n                    text.substring(0, lastOkayIndex),\n                    text.substring(lastOkayIndex),\n                ];\n            }\n        }\n    }\n};\n\nconst getLinesToRender = function(ctx, text, forcedWidth) {\n    const textSplitOnLines = text.split(/\\r\\n|\\r|\\n/g);\n\n    const lines = [];\n    for (let textLine of textSplitOnLines) {\n        let [nextLine, remainingText] = getNextLine(ctx, textLine, forcedWidth);\n        if (nextLine) {\n            while (nextLine) {\n                lines.push(nextLine);\n                [nextLine, remainingText] = getNextLine(\n                    ctx,\n                    remainingText,\n                    forcedWidth,\n                );\n            }\n        } else {\n            lines.push(textLine);\n        }\n    }\n    return lines;\n};\n\nclass TextRenderer {\n    constructor(ctx, text, font, forcedWidth, forcedHeight) {\n        this.text = text;\n        this.font = font;\n        this.forcedWidth = forcedWidth;\n        this.forcedHeight = forcedHeight;\n        const {fontFamily, fontSize} = parseFontString(this.font);\n\n        ctx.font = this.font;\n        ctx.textBaseline = "baseline";\n        this.emDashWidth = ctx.measureTextWidth(\n            "—",\n            fontSize,\n            fontFamily,\n        ).width;\n        this.caratWidth = ctx.measureTextWidth("|", fontSize, fontFamily).width;\n\n        this.lines = getLinesToRender(ctx, this.text, this.forcedWidth);\n\n        // we need to get metrics line by line and combine them. :-(\n        this.metricses = this.lines.map(line => {\n            return ctx.measureText2(line || "X", fontSize, this.font);\n        });\n\n        this.metrics = {\n            ascent: Math.max(...this.metricses.map(({ascent}) => ascent)),\n            descent: Math.max(...this.metricses.map(({descent}) => descent)),\n            fontsize: Math.max(...this.metricses.map(({fontsize}) => fontsize)),\n            leading: Math.max(...this.metricses.map(({leading}) => leading)),\n            width: Math.max(...this.metricses.map(({width}) => width)),\n            height: Math.max(...this.metricses.map(({height}) => height)),\n            bounds: {\n                minx: Math.min(\n                    ...this.metricses.map(({bounds}) => bounds.minx),\n                ),\n                miny: Math.min(\n                    ...this.metricses.map(({bounds}) => bounds.miny),\n                ),\n                maxx: Math.max(\n                    ...this.metricses.map(({bounds}) => bounds.maxx),\n                ),\n                maxy: Math.max(\n                    ...this.metricses.map(({bounds}) => bounds.maxy),\n                ),\n            },\n        };\n\n        this.boundingBoxWidth = Math.ceil(this.metrics.width);\n    }\n\n    draw(ctx, x, y) {\n        ctx.textBaseline = "top";\n        ctx.font = this.font;\n        let i = 0;\n\n        for (let line of this.lines) {\n            ctx.fillText(line, x, y + i++ * this.metrics.leading);\n        }\n    }\n\n    getWidth(isEditing) {\n        // if isEditing == true, add X padding to account for carat\n        if (isEditing == null) {\n            isEditing = false;\n        }\n        if (this.forcedWidth) {\n            return this.forcedWidth;\n        } else {\n            if (isEditing) {\n                return this.metrics.bounds.maxx + this.caratWidth;\n            } else {\n                return this.metrics.bounds.maxx;\n            }\n        }\n    }\n    getHeight() {\n        return this.forcedHeight || this.metrics.leading * this.lines.length;\n    }\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (TextRenderer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvVGV4dFJlbmRlcmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1RleHRSZW5kZXJlci5qcz83NDc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vZm9udG1ldHJpY3MuanNcIjtcblxuY29uc3QgcGFyc2VGb250U3RyaW5nID0gZnVuY3Rpb24oZm9udCkge1xuICAgIGNvbnN0IGZvbnRJdGVtcyA9IGZvbnQuc3BsaXQoXCIgXCIpO1xuXG4gICAgbGV0IGZvbnRTaXplID0gMDtcblxuICAgIGZvciAobGV0IGl0ZW0gb2YgZm9udEl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG1heWJlU2l6ZSA9IHBhcnNlSW50KGl0ZW0ucmVwbGFjZShcInB4XCIsIFwiXCIpLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4obWF5YmVTaXplKSkge1xuICAgICAgICAgICAgZm9udFNpemUgPSBtYXliZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICB0aHJvdyBcIkZvbnQgc2l6ZSBub3QgZm91bmRcIjtcbiAgICB9XG5cbiAgICBjb25zdCByZW1haW5pbmdGb250U3RyaW5nID0gZm9udFxuICAgICAgICAuc3Vic3RyaW5nKGZvbnRJdGVtc1swXS5sZW5ndGggKyAxKVxuICAgICAgICAucmVwbGFjZShcImJvbGQgXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiaXRhbGljIFwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcInVuZGVybGluZSBcIiwgXCJcIik7XG5cbiAgICBjb25zdCBmb250RmFtaWx5ID0gcmVtYWluaW5nRm9udFN0cmluZztcblxuICAgIHJldHVybiB7Zm9udFNpemUsIGZvbnRGYW1pbHl9O1xufTtcblxuY29uc3QgZ2V0TmV4dExpbmUgPSBmdW5jdGlvbihjdHgsIHRleHQsIGZvcmNlZFdpZHRoKSB7XG4gICAgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW1wiXCIsIFwiXCJdO1xuICAgIH1cblxuICAgIGxldCBlbmRJbmRleCA9IDA7XG4gICAgbGV0IGxhc3RHb29kSW5kZXggPSAwO1xuICAgIGxldCBsYXN0T2theUluZGV4ID0gMDtcbiAgICBsZXQgd2FzSW5Xb3JkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBlbmRJbmRleCArPSAxO1xuICAgICAgICBjb25zdCBpc0VuZE9mU3RyaW5nID0gZW5kSW5kZXggPj0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgaXNXaGl0ZXNwYWNlID0gIWlzRW5kT2ZTdHJpbmcgJiYgdGV4dFtlbmRJbmRleF0ubWF0Y2goL1xccy8pO1xuICAgICAgICBjb25zdCBpc05vbldvcmQgPSBpc1doaXRlc3BhY2UgfHwgaXNFbmRPZlN0cmluZztcblxuICAgICAgICBjb25zdCB0ZXh0VG9IZXJlID0gdGV4dC5zdWJzdHJpbmcoMCwgZW5kSW5kZXgpO1xuICAgICAgICBjb25zdCBkb2VzU3Vic3RyaW5nRml0ID0gZm9yY2VkV2lkdGhcbiAgICAgICAgICAgID8gY3R4Lm1lYXN1cmVUZXh0V2lkdGgodGV4dFRvSGVyZSkud2lkdGggPD0gZm9yY2VkV2lkdGhcbiAgICAgICAgICAgIDogdHJ1ZTtcblxuICAgICAgICBpZiAoZG9lc1N1YnN0cmluZ0ZpdCkge1xuICAgICAgICAgICAgbGFzdE9rYXlJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd29yZCAtPiBub24td29yZFxuICAgICAgICBpZiAoaXNOb25Xb3JkICYmIHdhc0luV29yZCkge1xuICAgICAgICAgICAgd2FzSW5Xb3JkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZG9lc1N1YnN0cmluZ0ZpdCkge1xuICAgICAgICAgICAgICAgIGxhc3RHb29kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdhc0luV29yZCA9ICFpc1doaXRlc3BhY2U7XG5cbiAgICAgICAgaWYgKGlzRW5kT2ZTdHJpbmcgfHwgIWRvZXNTdWJzdHJpbmdGaXQpIHtcbiAgICAgICAgICAgIGlmIChkb2VzU3Vic3RyaW5nRml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0ZXh0LCBcIlwiXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdEdvb2RJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFdvcmRTdGFydEluZGV4ID0gbGFzdEdvb2RJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0V29yZFN0YXJ0SW5kZXggPCB0ZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0ZXh0W25leHRXb3JkU3RhcnRJbmRleF0ubWF0Y2goL1xccy8pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRXb3JkU3RhcnRJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCBsYXN0R29vZEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcobmV4dFdvcmRTdGFydEluZGV4KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCBsYXN0T2theUluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcobGFzdE9rYXlJbmRleCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IGdldExpbmVzVG9SZW5kZXIgPSBmdW5jdGlvbihjdHgsIHRleHQsIGZvcmNlZFdpZHRoKSB7XG4gICAgY29uc3QgdGV4dFNwbGl0T25MaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpO1xuXG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB0ZXh0TGluZSBvZiB0ZXh0U3BsaXRPbkxpbmVzKSB7XG4gICAgICAgIGxldCBbbmV4dExpbmUsIHJlbWFpbmluZ1RleHRdID0gZ2V0TmV4dExpbmUoY3R4LCB0ZXh0TGluZSwgZm9yY2VkV2lkdGgpO1xuICAgICAgICBpZiAobmV4dExpbmUpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0TGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobmV4dExpbmUpO1xuICAgICAgICAgICAgICAgIFtuZXh0TGluZSwgcmVtYWluaW5nVGV4dF0gPSBnZXROZXh0TGluZShcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRXaWR0aCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCh0ZXh0TGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuY2xhc3MgVGV4dFJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjdHgsIHRleHQsIGZvbnQsIGZvcmNlZFdpZHRoLCBmb3JjZWRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5mb250ID0gZm9udDtcbiAgICAgICAgdGhpcy5mb3JjZWRXaWR0aCA9IGZvcmNlZFdpZHRoO1xuICAgICAgICB0aGlzLmZvcmNlZEhlaWdodCA9IGZvcmNlZEhlaWdodDtcbiAgICAgICAgY29uc3Qge2ZvbnRGYW1pbHksIGZvbnRTaXplfSA9IHBhcnNlRm9udFN0cmluZyh0aGlzLmZvbnQpO1xuXG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJiYXNlbGluZVwiO1xuICAgICAgICB0aGlzLmVtRGFzaFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0V2lkdGgoXG4gICAgICAgICAgICBcIuKAlFwiLFxuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICApLndpZHRoO1xuICAgICAgICB0aGlzLmNhcmF0V2lkdGggPSBjdHgubWVhc3VyZVRleHRXaWR0aChcInxcIiwgZm9udFNpemUsIGZvbnRGYW1pbHkpLndpZHRoO1xuXG4gICAgICAgIHRoaXMubGluZXMgPSBnZXRMaW5lc1RvUmVuZGVyKGN0eCwgdGhpcy50ZXh0LCB0aGlzLmZvcmNlZFdpZHRoKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGdldCBtZXRyaWNzIGxpbmUgYnkgbGluZSBhbmQgY29tYmluZSB0aGVtLiA6LShcbiAgICAgICAgdGhpcy5tZXRyaWNzZXMgPSB0aGlzLmxpbmVzLm1hcChsaW5lID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQyKGxpbmUgfHwgXCJYXCIsIGZvbnRTaXplLCB0aGlzLmZvbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICAgICAgICBhc2NlbnQ6IE1hdGgubWF4KC4uLnRoaXMubWV0cmljc2VzLm1hcCgoe2FzY2VudH0pID0+IGFzY2VudCkpLFxuICAgICAgICAgICAgZGVzY2VudDogTWF0aC5tYXgoLi4udGhpcy5tZXRyaWNzZXMubWFwKCh7ZGVzY2VudH0pID0+IGRlc2NlbnQpKSxcbiAgICAgICAgICAgIGZvbnRzaXplOiBNYXRoLm1heCguLi50aGlzLm1ldHJpY3Nlcy5tYXAoKHtmb250c2l6ZX0pID0+IGZvbnRzaXplKSksXG4gICAgICAgICAgICBsZWFkaW5nOiBNYXRoLm1heCguLi50aGlzLm1ldHJpY3Nlcy5tYXAoKHtsZWFkaW5nfSkgPT4gbGVhZGluZykpLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KC4uLnRoaXMubWV0cmljc2VzLm1hcCgoe3dpZHRofSkgPT4gd2lkdGgpKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoLi4udGhpcy5tZXRyaWNzZXMubWFwKCh7aGVpZ2h0fSkgPT4gaGVpZ2h0KSksXG4gICAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgICAgICBtaW54OiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5tZXRyaWNzZXMubWFwKCh7Ym91bmRzfSkgPT4gYm91bmRzLm1pbngpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWlueTogTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMubWV0cmljc2VzLm1hcCgoe2JvdW5kc30pID0+IGJvdW5kcy5taW55KSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1heHg6IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLm1ldHJpY3Nlcy5tYXAoKHtib3VuZHN9KSA9PiBib3VuZHMubWF4eCksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXh5OiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5tZXRyaWNzZXMubWFwKCh7Ym91bmRzfSkgPT4gYm91bmRzLm1heHkpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3hXaWR0aCA9IE1hdGguY2VpbCh0aGlzLm1ldHJpY3Mud2lkdGgpO1xuICAgIH1cblxuICAgIGRyYXcoY3R4LCB4LCB5KSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udDtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy5saW5lcykge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHkgKyBpKysgKiB0aGlzLm1ldHJpY3MubGVhZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRXaWR0aChpc0VkaXRpbmcpIHtcbiAgICAgICAgLy8gaWYgaXNFZGl0aW5nID09IHRydWUsIGFkZCBYIHBhZGRpbmcgdG8gYWNjb3VudCBmb3IgY2FyYXRcbiAgICAgICAgaWYgKGlzRWRpdGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb3JjZWRXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yY2VkV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0cmljcy5ib3VuZHMubWF4eCArIHRoaXMuY2FyYXRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0cmljcy5ib3VuZHMubWF4eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcmNlZEhlaWdodCB8fCB0aGlzLm1ldHJpY3MubGVhZGluZyAqIHRoaXMubGluZXMubGVuZ3RoO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFJlbmRlcmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/TextRenderer.js\n',
                );

                /***/
            },

        /***/ "./src/actions.js":
            /*!************************!*\
  !*** ./src/actions.js ***!
  \************************/
            /*! exports provided: ClearAction, MoveAction, AddShapeAction */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClearAction", function() { return ClearAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveAction", function() { return MoveAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddShapeAction", function() { return AddShapeAction; });\n// maybe add checks to these in the future to make sure you never double-undo or\n// double-redo\nclass ClearAction {\n    constructor(lc, oldShapes, newShapes) {\n        this.lc = lc;\n        this.oldShapes = oldShapes;\n        this.newShapes = newShapes;\n    }\n\n    do() {\n        this.lc.shapes = this.newShapes;\n        this.lc.repaintLayer("main");\n    }\n\n    undo() {\n        this.lc.shapes = this.oldShapes;\n        this.lc.repaintLayer("main");\n    }\n}\n\nclass MoveAction {\n    constructor(lc, selectedShape, previousPosition, newPosition) {\n        this.lc = lc;\n        this.selectedShape = selectedShape;\n        this.previousPosition = previousPosition;\n        this.newPosition = newPosition;\n    }\n\n    do() {\n        this.selectedShape.setUpperLeft({\n            x: this.newPosition.x,\n            y: this.newPosition.y,\n        });\n        this.lc.repaintLayer("main");\n    }\n\n    undo() {\n        this.selectedShape.setUpperLeft({\n            x: this.previousPosition.x,\n            y: this.previousPosition.y,\n        });\n        this.lc.repaintLayer("main");\n    }\n}\n\nclass AddShapeAction {\n    constructor(lc, shape, previousShapeId = null) {\n        this.lc = lc;\n        this.shape = shape;\n        this.previousShapeId = previousShapeId;\n    }\n\n    do() {\n        // common case: just add it to the end\n        if (\n            !this.lc.shapes.length ||\n            this.lc.shapes[this.lc.shapes.length - 1].id ===\n                this.previousShapeId ||\n            this.previousShapeId === null\n        ) {\n            this.lc.shapes.push(this.shape);\n            // uncommon case: insert it somewhere\n        } else {\n            const newShapes = [];\n            let found = false;\n            for (let shape of this.lc.shapes) {\n                newShapes.push(shape);\n                if (shape.id === this.previousShapeId) {\n                    newShapes.push(this.shape);\n                    found = true;\n                }\n            }\n            if (!found) {\n                // given ID doesn\'t exist, just shove it on top\n                newShapes.push(this.shape);\n            }\n            this.lc.shapes = newShapes;\n        }\n        this.lc.repaintLayer("main");\n    }\n\n    undo() {\n        // common case: it\'s the most recent shape\n        if (this.lc.shapes[this.lc.shapes.length - 1].id === this.shape.id) {\n            this.lc.shapes.pop();\n            // uncommon case: it\'s in the array somewhere\n        } else {\n            const newShapes = [];\n            for (let shape of this.lc.shapes) {\n                if (shape.id !== this.shape.id) {\n                    newShapes.push(shape);\n                }\n            }\n            this.lc.shapes = newShapes;\n        }\n        this.lc.repaintLayer("main");\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWN0aW9ucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hY3Rpb25zLmpzPzM0ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbWF5YmUgYWRkIGNoZWNrcyB0byB0aGVzZSBpbiB0aGUgZnV0dXJlIHRvIG1ha2Ugc3VyZSB5b3UgbmV2ZXIgZG91YmxlLXVuZG8gb3Jcbi8vIGRvdWJsZS1yZWRvXG5jbGFzcyBDbGVhckFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IobGMsIG9sZFNoYXBlcywgbmV3U2hhcGVzKSB7XG4gICAgICAgIHRoaXMubGMgPSBsYztcbiAgICAgICAgdGhpcy5vbGRTaGFwZXMgPSBvbGRTaGFwZXM7XG4gICAgICAgIHRoaXMubmV3U2hhcGVzID0gbmV3U2hhcGVzO1xuICAgIH1cblxuICAgIGRvKCkge1xuICAgICAgICB0aGlzLmxjLnNoYXBlcyA9IHRoaXMubmV3U2hhcGVzO1xuICAgICAgICB0aGlzLmxjLnJlcGFpbnRMYXllcihcIm1haW5cIik7XG4gICAgfVxuXG4gICAgdW5kbygpIHtcbiAgICAgICAgdGhpcy5sYy5zaGFwZXMgPSB0aGlzLm9sZFNoYXBlcztcbiAgICAgICAgdGhpcy5sYy5yZXBhaW50TGF5ZXIoXCJtYWluXCIpO1xuICAgIH1cbn1cblxuY2xhc3MgTW92ZUFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IobGMsIHNlbGVjdGVkU2hhcGUsIHByZXZpb3VzUG9zaXRpb24sIG5ld1Bvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMubGMgPSBsYztcbiAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlID0gc2VsZWN0ZWRTaGFwZTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID0gcHJldmlvdXNQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cblxuICAgIGRvKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUuc2V0VXBwZXJMZWZ0KHtcbiAgICAgICAgICAgIHg6IHRoaXMubmV3UG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IHRoaXMubmV3UG9zaXRpb24ueSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGMucmVwYWludExheWVyKFwibWFpblwiKTtcbiAgICB9XG5cbiAgICB1bmRvKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUuc2V0VXBwZXJMZWZ0KHtcbiAgICAgICAgICAgIHg6IHRoaXMucHJldmlvdXNQb3NpdGlvbi54LFxuICAgICAgICAgICAgeTogdGhpcy5wcmV2aW91c1Bvc2l0aW9uLnksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjLnJlcGFpbnRMYXllcihcIm1haW5cIik7XG4gICAgfVxufVxuXG5jbGFzcyBBZGRTaGFwZUFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IobGMsIHNoYXBlLCBwcmV2aW91c1NoYXBlSWQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMubGMgPSBsYztcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLnByZXZpb3VzU2hhcGVJZCA9IHByZXZpb3VzU2hhcGVJZDtcbiAgICB9XG5cbiAgICBkbygpIHtcbiAgICAgICAgLy8gY29tbW9uIGNhc2U6IGp1c3QgYWRkIGl0IHRvIHRoZSBlbmRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMubGMuc2hhcGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5sYy5zaGFwZXNbdGhpcy5sYy5zaGFwZXMubGVuZ3RoIC0gMV0uaWQgPT09XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NoYXBlSWQgfHxcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNTaGFwZUlkID09PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sYy5zaGFwZXMucHVzaCh0aGlzLnNoYXBlKTtcbiAgICAgICAgICAgIC8vIHVuY29tbW9uIGNhc2U6IGluc2VydCBpdCBzb21ld2hlcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NoYXBlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBzaGFwZSBvZiB0aGlzLmxjLnNoYXBlcykge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaWQgPT09IHRoaXMucHJldmlvdXNTaGFwZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlcy5wdXNoKHRoaXMuc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIGdpdmVuIElEIGRvZXNuJ3QgZXhpc3QsIGp1c3Qgc2hvdmUgaXQgb24gdG9wXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVzLnB1c2godGhpcy5zaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxjLnNoYXBlcyA9IG5ld1NoYXBlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxjLnJlcGFpbnRMYXllcihcIm1haW5cIik7XG4gICAgfVxuXG4gICAgdW5kbygpIHtcbiAgICAgICAgLy8gY29tbW9uIGNhc2U6IGl0J3MgdGhlIG1vc3QgcmVjZW50IHNoYXBlXG4gICAgICAgIGlmICh0aGlzLmxjLnNoYXBlc1t0aGlzLmxjLnNoYXBlcy5sZW5ndGggLSAxXS5pZCA9PT0gdGhpcy5zaGFwZS5pZCkge1xuICAgICAgICAgICAgdGhpcy5sYy5zaGFwZXMucG9wKCk7XG4gICAgICAgICAgICAvLyB1bmNvbW1vbiBjYXNlOiBpdCdzIGluIHRoZSBhcnJheSBzb21ld2hlcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NoYXBlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc2hhcGUgb2YgdGhpcy5sYy5zaGFwZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaWQgIT09IHRoaXMuc2hhcGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGMuc2hhcGVzID0gbmV3U2hhcGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGMucmVwYWludExheWVyKFwibWFpblwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7Q2xlYXJBY3Rpb24sIE1vdmVBY3Rpb24sIEFkZFNoYXBlQWN0aW9ufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/actions.js\n',
                );

                /***/
            },

        /***/ "./src/bindEvents.js":
            /*!***************************!*\
  !*** ./src/bindEvents.js ***!
  \***************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\nconst coordsForTouchEvent = function(el, e) {\n    const tx = e.changedTouches[0].clientX;\n    const ty = e.changedTouches[0].clientY;\n    const p = el.getBoundingClientRect();\n    return [tx - p.left, ty - p.top];\n};\n\nconst position = function(el, e) {\n    const p = el.getBoundingClientRect();\n    return {\n        left: e.clientX - p.left,\n        top: e.clientY - p.top,\n    };\n};\n\nconst buttonIsDown = function(e) {\n    if (e.buttons != null) {\n        return e.buttons === 1;\n    } else {\n        return e.which > 0;\n    }\n};\n\nconst bindEvents = function(lc, canvas, panWithKeyboard) {\n    if (panWithKeyboard == null) {\n        panWithKeyboard = false;\n    }\n    const unsubs = [];\n\n    const mouseMoveListener = e => {\n        e.preventDefault();\n        const p = position(canvas, e);\n        lc.pointerMove(p.left, p.top);\n    };\n\n    var mouseUpListener = e => {\n        e.preventDefault();\n        canvas.onselectstart = () => true; // enable selection while dragging\n        const p = position(canvas, e);\n        lc.pointerUp(p.left, p.top);\n        document.removeEventListener("mousemove", mouseMoveListener);\n        document.removeEventListener("mouseup", mouseUpListener);\n\n        canvas.addEventListener("mousemove", mouseMoveListener);\n    };\n\n    canvas.addEventListener("mousedown", e => {\n        if (e.target.tagName.toLowerCase() !== "canvas") {\n            return;\n        }\n\n        const down = true;\n        e.preventDefault();\n        canvas.onselectstart = () => false; // disable selection while dragging\n        const p = position(canvas, e);\n        lc.pointerDown(p.left, p.top);\n\n        canvas.removeEventListener("mousemove", mouseMoveListener);\n        document.addEventListener("mousemove", mouseMoveListener);\n        document.addEventListener("mouseup", mouseUpListener);\n    });\n\n    const touchMoveListener = function(e) {\n        e.preventDefault();\n        lc.pointerMove(...coordsForTouchEvent(canvas, e));\n    };\n\n    var touchEndListener = function(e) {\n        e.preventDefault();\n        lc.pointerUp(...coordsForTouchEvent(canvas, e));\n        document.removeEventListener("touchmove", touchMoveListener);\n        document.removeEventListener("touchend", touchEndListener);\n        document.removeEventListener("touchcancel", touchEndListener);\n    };\n\n    canvas.addEventListener("touchstart", function(e) {\n        if (e.target.tagName.toLowerCase() !== "canvas") {\n            return;\n        }\n        e.preventDefault();\n        if (e.touches.length === 1) {\n            lc.pointerDown(...coordsForTouchEvent(canvas, e));\n            document.addEventListener("touchmove", touchMoveListener);\n            document.addEventListener("touchend", touchEndListener);\n            document.addEventListener("touchcancel", touchEndListener);\n        } else {\n            lc.pointerMove(...coordsForTouchEvent(canvas, e));\n        }\n    });\n\n    if (panWithKeyboard) {\n        console.warn("Keyboard panning is deprecated.");\n        const listener = function(e) {\n            switch (e.keyCode) {\n                case 37:\n                    lc.pan(-10, 0);\n                    break;\n                case 38:\n                    lc.pan(0, -10);\n                    break;\n                case 39:\n                    lc.pan(10, 0);\n                    break;\n                case 40:\n                    lc.pan(0, 10);\n                    break;\n            }\n            lc.repaintAllLayers();\n        };\n\n        document.addEventListener("keydown", listener);\n        unsubs.push(() => document.removeEventListener(listener));\n    }\n\n    return () => unsubs.map(f => f());\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (bindEvents);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmluZEV2ZW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9iaW5kRXZlbnRzLmpzPzVkOGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29vcmRzRm9yVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGVsLCBlKSB7XG4gICAgY29uc3QgdHggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XG4gICAgY29uc3QgdHkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgY29uc3QgcCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBbdHggLSBwLmxlZnQsIHR5IC0gcC50b3BdO1xufTtcblxuY29uc3QgcG9zaXRpb24gPSBmdW5jdGlvbihlbCwgZSkge1xuICAgIGNvbnN0IHAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBlLmNsaWVudFggLSBwLmxlZnQsXG4gICAgICAgIHRvcDogZS5jbGllbnRZIC0gcC50b3AsXG4gICAgfTtcbn07XG5cbmNvbnN0IGJ1dHRvbklzRG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5idXR0b25zICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGUuYnV0dG9ucyA9PT0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZS53aGljaCA+IDA7XG4gICAgfVxufTtcblxuY29uc3QgYmluZEV2ZW50cyA9IGZ1bmN0aW9uKGxjLCBjYW52YXMsIHBhbldpdGhLZXlib2FyZCkge1xuICAgIGlmIChwYW5XaXRoS2V5Ym9hcmQgPT0gbnVsbCkge1xuICAgICAgICBwYW5XaXRoS2V5Ym9hcmQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzID0gW107XG5cbiAgICBjb25zdCBtb3VzZU1vdmVMaXN0ZW5lciA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBwb3NpdGlvbihjYW52YXMsIGUpO1xuICAgICAgICBsYy5wb2ludGVyTW92ZShwLmxlZnQsIHAudG9wKTtcbiAgICB9O1xuXG4gICAgdmFyIG1vdXNlVXBMaXN0ZW5lciA9IGUgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbnZhcy5vbnNlbGVjdHN0YXJ0ID0gKCkgPT4gdHJ1ZTsgLy8gZW5hYmxlIHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICBjb25zdCBwID0gcG9zaXRpb24oY2FudmFzLCBlKTtcbiAgICAgICAgbGMucG9pbnRlclVwKHAubGVmdCwgcC50b3ApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcExpc3RlbmVyKTtcblxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmVMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkb3duID0gdHJ1ZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW52YXMub25zZWxlY3RzdGFydCA9ICgpID0+IGZhbHNlOyAvLyBkaXNhYmxlIHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICBjb25zdCBwID0gcG9zaXRpb24oY2FudmFzLCBlKTtcbiAgICAgICAgbGMucG9pbnRlckRvd24ocC5sZWZ0LCBwLnRvcCk7XG5cbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcExpc3RlbmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvdWNoTW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxjLnBvaW50ZXJNb3ZlKC4uLmNvb3Jkc0ZvclRvdWNoRXZlbnQoY2FudmFzLCBlKSk7XG4gICAgfTtcblxuICAgIHZhciB0b3VjaEVuZExpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxjLnBvaW50ZXJVcCguLi5jb29yZHNGb3JUb3VjaEV2ZW50KGNhbnZhcywgZSkpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRvdWNoTW92ZUxpc3RlbmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRvdWNoRW5kTGlzdGVuZXIpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsYy5wb2ludGVyRG93biguLi5jb29yZHNGb3JUb3VjaEV2ZW50KGNhbnZhcywgZSkpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0b3VjaE1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdG91Y2hFbmRMaXN0ZW5lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYy5wb2ludGVyTW92ZSguLi5jb29yZHNGb3JUb3VjaEV2ZW50KGNhbnZhcywgZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGFuV2l0aEtleWJvYXJkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIktleWJvYXJkIHBhbm5pbmcgaXMgZGVwcmVjYXRlZC5cIik7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAgICAgICBsYy5wYW4oLTEwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgICAgbGMucGFuKDAsIC0xMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgIGxjLnBhbigxMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgIGxjLnBhbigwLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGMucmVwYWludEFsbExheWVycygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgdW5zdWJzLnB1c2goKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB1bnN1YnMubWFwKGYgPT4gZigpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJpbmRFdmVudHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/bindEvents.js\n',
                );

                /***/
            },

        /***/ "./src/canvasRenderer.js":
            /*!*******************************!*\
  !*** ./src/canvasRenderer.js ***!
  \*******************************/
            /*! exports provided: defineCanvasRenderer, renderShapeToCanvas, renderShapeToContext */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineCanvasRenderer", function() { return defineCanvasRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderShapeToCanvas", function() { return renderShapeToCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderShapeToContext", function() { return renderShapeToContext; });\n/* harmony import */ var _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineEndCapShapes */ "./src/lineEndCapShapes.js");\n\n\nconst renderers = {};\n\n// drawFunc(ctx, shape, retryCallback)\n// drawLatest(ctx, bufferCtx, shape, retryCallback)\nconst defineCanvasRenderer = (shapeName, drawFunc, drawLatestFunc) =>\n    (renderers[shapeName] = {drawFunc, drawLatestFunc});\n\nconst noop = function() {};\nconst renderShapeToContext = function(ctx, shape, opts) {\n    if (opts == null) {\n        opts = {};\n    }\n    if (opts.shouldIgnoreUnsupportedShapes == null) {\n        opts.shouldIgnoreUnsupportedShapes = false;\n    }\n    if (opts.retryCallback == null) {\n        opts.retryCallback = noop;\n    }\n    if (opts.shouldOnlyDrawLatest == null) {\n        opts.shouldOnlyDrawLatest = false;\n    }\n    if (opts.bufferCtx == null) {\n        opts.bufferCtx = null;\n    }\n    const {bufferCtx} = opts;\n\n    if (renderers[shape.className]) {\n        if (\n            opts.shouldOnlyDrawLatest &&\n            renderers[shape.className].drawLatestFunc\n        ) {\n            renderers[shape.className].drawLatestFunc(\n                ctx,\n                bufferCtx,\n                shape,\n                opts.retryCallback,\n            );\n        } else {\n            renderers[shape.className].drawFunc(ctx, shape, opts.retryCallback);\n        }\n    } else if (opts.shouldIgnoreUnsupportedShapes) {\n        console.warn(`Can\'t render shape of type ${shape.className} to canvas`);\n    } else {\n        throw `Can\'t render shape of type ${shape.className} to canvas`;\n    }\n};\n\nconst renderShapeToCanvas = (canvas, shape, opts) =>\n    renderShapeToContext(canvas.getContext("2d"), shape, opts);\n\ndefineCanvasRenderer("Rectangle", function(ctx, shape) {\n    let {x} = shape;\n    let {y} = shape;\n    if (shape.strokeWidth % 2 !== 0) {\n        x += 0.5;\n        y += 0.5;\n    }\n\n    ctx.fillStyle = shape.fillColor;\n    ctx.fillRect(x, y, shape.width, shape.height);\n    ctx.lineWidth = shape.strokeWidth;\n    ctx.strokeStyle = shape.strokeColor;\n    ctx.strokeRect(x, y, shape.width, shape.height);\n});\n\ndefineCanvasRenderer("Ellipse", function(ctx, shape) {\n    ctx.save();\n    const halfWidth = Math.floor(shape.width / 2);\n    const halfHeight = Math.floor(shape.height / 2);\n    const centerX = shape.x + halfWidth;\n    const centerY = shape.y + halfHeight;\n\n    ctx.translate(centerX, centerY);\n    ctx.scale(1, Math.abs(shape.height / shape.width));\n    ctx.beginPath();\n    ctx.arc(0, 0, Math.abs(halfWidth), 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.restore();\n\n    ctx.fillStyle = shape.fillColor;\n    ctx.fill();\n    ctx.lineWidth = shape.strokeWidth;\n    ctx.strokeStyle = shape.strokeColor;\n    ctx.stroke();\n});\n\ndefineCanvasRenderer(\n    "SelectionBox",\n    (function() {\n        const _drawHandle = function(ctx, {x, y}, handleSize) {\n            if (handleSize === 0) {\n                return;\n            }\n\n            ctx.fillStyle = "#fff";\n            ctx.fillRect(x, y, handleSize, handleSize);\n            ctx.strokeStyle = "#000";\n            ctx.strokeRect(x, y, handleSize, handleSize);\n        };\n\n        return function(ctx, shape) {\n            _drawHandle(ctx, shape.getTopLeftHandleRect(), shape.handleSize);\n            _drawHandle(ctx, shape.getTopRightHandleRect(), shape.handleSize);\n            _drawHandle(ctx, shape.getBottomLeftHandleRect(), shape.handleSize);\n            _drawHandle(\n                ctx,\n                shape.getBottomRightHandleRect(),\n                shape.handleSize,\n            );\n\n            if (shape.backgroundColor) {\n                ctx.fillStyle = shape.backgroundColor;\n                ctx.fillRect(\n                    shape._br.x - shape.margin,\n                    shape._br.y - shape.margin,\n                    shape._br.width + shape.margin * 2,\n                    shape._br.height + shape.margin * 2,\n                );\n            }\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = shape.backgroundColor || "#000";\n            ctx.setLineDash([2, 4]);\n            ctx.strokeRect(\n                shape._br.x - shape.margin,\n                shape._br.y - shape.margin,\n                shape._br.width + shape.margin * 2,\n                shape._br.height + shape.margin * 2,\n            );\n\n            ctx.setLineDash([]);\n        };\n    })(),\n);\n\ndefineCanvasRenderer("Image", function(ctx, shape, retryCallback) {\n    if (shape.image.width) {\n        if (shape.scale === 1) {\n            ctx.drawImage(shape.image, shape.x, shape.y);\n        } else {\n            return ctx.drawImage(\n                shape.image,\n                shape.x,\n                shape.y,\n                shape.image.width * shape.scale,\n                shape.image.height * shape.scale,\n            );\n        }\n    } else if (retryCallback) {\n        shape.image.onload = retryCallback;\n    }\n});\n\ndefineCanvasRenderer("Line", function(ctx, shape) {\n    if (shape.x1 === shape.x2 && shape.y1 === shape.y2) {\n        // browser behavior is not consistent for this case.\n        return;\n    }\n\n    let {x1} = shape;\n    let {x2} = shape;\n    let {y1} = shape;\n    let {y2} = shape;\n    if (shape.strokeWidth % 2 !== 0) {\n        x1 += 0.5;\n        x2 += 0.5;\n        y1 += 0.5;\n        y2 += 0.5;\n    }\n\n    ctx.lineWidth = shape.strokeWidth;\n    ctx.strokeStyle = shape.color;\n    ctx.lineCap = shape.capStyle;\n    if (shape.dash) {\n        ctx.setLineDash(shape.dash);\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    if (shape.dash) {\n        ctx.setLineDash([]);\n    }\n\n    const arrowWidth = Math.max(shape.strokeWidth * 2.2, 5);\n    if (shape.endCapShapes[0]) {\n        _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__["default"][shape.endCapShapes[0]].drawToCanvas(\n            ctx,\n            x1,\n            y1,\n            Math.atan2(y1 - y2, x1 - x2),\n            arrowWidth,\n            shape.color,\n        );\n    }\n    if (shape.endCapShapes[1]) {\n        _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__["default"][shape.endCapShapes[1]].drawToCanvas(\n            ctx,\n            x2,\n            y2,\n            Math.atan2(y2 - y1, x2 - x1),\n            arrowWidth,\n            shape.color,\n        );\n    }\n});\n\nconst _drawRawLinePath = function(ctx, points, close, lineCap) {\n    if (close == null) {\n        close = false;\n    }\n    if (lineCap == null) {\n        lineCap = "round";\n    }\n    if (!points.length) {\n        return;\n    }\n\n    ctx.lineCap = lineCap;\n\n    ctx.strokeStyle = points[0].color;\n    ctx.lineWidth = points[0].size;\n\n    ctx.beginPath();\n\n    if (points[0].size % 2 === 0) {\n        ctx.moveTo(points[0].x, points[0].y);\n    } else {\n        ctx.moveTo(points[0].x + 0.5, points[0].y + 0.5);\n    }\n\n    for (let point of points.slice(1)) {\n        if (points[0].size % 2 === 0) {\n            ctx.lineTo(point.x, point.y);\n        } else {\n            ctx.lineTo(point.x + 0.5, point.y + 0.5);\n        }\n    }\n\n    if (close) {\n        ctx.closePath();\n    }\n};\n\nconst drawLinePath = function(ctx, shape) {\n    _drawRawLinePath(ctx, shape.smoothedPoints);\n    ctx.stroke();\n};\nconst drawLinePathLatest = function(ctx, bufferCtx, shape) {\n    if (shape.tail) {\n        const segmentStart =\n            shape.smoothedPoints.length - shape.segmentSize * shape.tailSize;\n        const drawStart =\n            segmentStart < shape.segmentSize * 2 ? 0 : segmentStart;\n\n        const drawEnd = segmentStart + shape.segmentSize + 1;\n\n        _drawRawLinePath(\n            bufferCtx,\n            shape.smoothedPoints.slice(drawStart, drawEnd),\n        );\n        bufferCtx.stroke();\n    } else {\n        _drawRawLinePath(bufferCtx, shape.smoothedPoints);\n        bufferCtx.stroke();\n    }\n};\n\ndefineCanvasRenderer("LinePath", drawLinePath, drawLinePathLatest);\n\n// same as the line path funcs, but erase instead of draw\nconst drawErasedLinePath = function(ctx, shape) {\n    ctx.save();\n    ctx.globalCompositeOperation = "destination-out";\n    drawLinePath(ctx, shape);\n    ctx.restore();\n};\nconst drawErasedLinePathLatest = function(ctx, bufferCtx, shape) {\n    ctx.save();\n    ctx.globalCompositeOperation = "destination-out";\n    bufferCtx.save();\n    bufferCtx.globalCompositeOperation = "destination-out";\n\n    drawLinePathLatest(ctx, bufferCtx, shape);\n\n    ctx.restore();\n    bufferCtx.restore();\n};\n\ndefineCanvasRenderer(\n    "ErasedLinePath",\n    drawErasedLinePath,\n    drawErasedLinePathLatest,\n);\n\ndefineCanvasRenderer("Text", function(ctx, shape) {\n    if (!shape.renderer) {\n        shape._makeRenderer(ctx);\n    }\n    ctx.fillStyle = shape.color;\n    shape.renderer.draw(ctx, shape.x, shape.y);\n});\n\ndefineCanvasRenderer("Polygon", function(ctx, shape) {\n    ctx.fillStyle = shape.fillColor;\n    _drawRawLinePath(ctx, shape.points, shape.isClosed, "butt");\n    ctx.fill();\n    ctx.stroke();\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2FudmFzUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzUmVuZGVyZXIuanM/YmUwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbGluZUVuZENhcFNoYXBlcyBmcm9tIFwiLi9saW5lRW5kQ2FwU2hhcGVzXCI7XG5cbmNvbnN0IHJlbmRlcmVycyA9IHt9O1xuXG4vLyBkcmF3RnVuYyhjdHgsIHNoYXBlLCByZXRyeUNhbGxiYWNrKVxuLy8gZHJhd0xhdGVzdChjdHgsIGJ1ZmZlckN0eCwgc2hhcGUsIHJldHJ5Q2FsbGJhY2spXG5jb25zdCBkZWZpbmVDYW52YXNSZW5kZXJlciA9IChzaGFwZU5hbWUsIGRyYXdGdW5jLCBkcmF3TGF0ZXN0RnVuYykgPT5cbiAgICAocmVuZGVyZXJzW3NoYXBlTmFtZV0gPSB7ZHJhd0Z1bmMsIGRyYXdMYXRlc3RGdW5jfSk7XG5cbmNvbnN0IG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuY29uc3QgcmVuZGVyU2hhcGVUb0NvbnRleHQgPSBmdW5jdGlvbihjdHgsIHNoYXBlLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGlmIChvcHRzLnNob3VsZElnbm9yZVVuc3VwcG9ydGVkU2hhcGVzID09IG51bGwpIHtcbiAgICAgICAgb3B0cy5zaG91bGRJZ25vcmVVbnN1cHBvcnRlZFNoYXBlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXRyeUNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgb3B0cy5yZXRyeUNhbGxiYWNrID0gbm9vcDtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2hvdWxkT25seURyYXdMYXRlc3QgPT0gbnVsbCkge1xuICAgICAgICBvcHRzLnNob3VsZE9ubHlEcmF3TGF0ZXN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRzLmJ1ZmZlckN0eCA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMuYnVmZmVyQ3R4ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge2J1ZmZlckN0eH0gPSBvcHRzO1xuXG4gICAgaWYgKHJlbmRlcmVyc1tzaGFwZS5jbGFzc05hbWVdKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9wdHMuc2hvdWxkT25seURyYXdMYXRlc3QgJiZcbiAgICAgICAgICAgIHJlbmRlcmVyc1tzaGFwZS5jbGFzc05hbWVdLmRyYXdMYXRlc3RGdW5jXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVuZGVyZXJzW3NoYXBlLmNsYXNzTmFtZV0uZHJhd0xhdGVzdEZ1bmMoXG4gICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgIGJ1ZmZlckN0eCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBvcHRzLnJldHJ5Q2FsbGJhY2ssXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZXJzW3NoYXBlLmNsYXNzTmFtZV0uZHJhd0Z1bmMoY3R4LCBzaGFwZSwgb3B0cy5yZXRyeUNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5zaG91bGRJZ25vcmVVbnN1cHBvcnRlZFNoYXBlcykge1xuICAgICAgICBjb25zb2xlLndhcm4oYENhbid0IHJlbmRlciBzaGFwZSBvZiB0eXBlICR7c2hhcGUuY2xhc3NOYW1lfSB0byBjYW52YXNgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgQ2FuJ3QgcmVuZGVyIHNoYXBlIG9mIHR5cGUgJHtzaGFwZS5jbGFzc05hbWV9IHRvIGNhbnZhc2A7XG4gICAgfVxufTtcblxuY29uc3QgcmVuZGVyU2hhcGVUb0NhbnZhcyA9IChjYW52YXMsIHNoYXBlLCBvcHRzKSA9PlxuICAgIHJlbmRlclNoYXBlVG9Db250ZXh0KGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHNoYXBlLCBvcHRzKTtcblxuZGVmaW5lQ2FudmFzUmVuZGVyZXIoXCJSZWN0YW5nbGVcIiwgZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuICAgIGxldCB7eH0gPSBzaGFwZTtcbiAgICBsZXQge3l9ID0gc2hhcGU7XG4gICAgaWYgKHNoYXBlLnN0cm9rZVdpZHRoICUgMiAhPT0gMCkge1xuICAgICAgICB4ICs9IDAuNTtcbiAgICAgICAgeSArPSAwLjU7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxTdHlsZSA9IHNoYXBlLmZpbGxDb2xvcjtcbiAgICBjdHguZmlsbFJlY3QoeCwgeSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHNoYXBlLnN0cm9rZUNvbG9yO1xuICAgIGN0eC5zdHJva2VSZWN0KHgsIHksIHNoYXBlLndpZHRoLCBzaGFwZS5oZWlnaHQpO1xufSk7XG5cbmRlZmluZUNhbnZhc1JlbmRlcmVyKFwiRWxsaXBzZVwiLCBmdW5jdGlvbihjdHgsIHNoYXBlKSB7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSBNYXRoLmZsb29yKHNoYXBlLndpZHRoIC8gMik7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGguZmxvb3Ioc2hhcGUuaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY2VudGVyWCA9IHNoYXBlLnggKyBoYWxmV2lkdGg7XG4gICAgY29uc3QgY2VudGVyWSA9IHNoYXBlLnkgKyBoYWxmSGVpZ2h0O1xuXG4gICAgY3R4LnRyYW5zbGF0ZShjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHguc2NhbGUoMSwgTWF0aC5hYnMoc2hhcGUuaGVpZ2h0IC8gc2hhcGUud2lkdGgpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYygwLCAwLCBNYXRoLmFicyhoYWxmV2lkdGgpLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gc2hhcGUuZmlsbENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHNoYXBlLnN0cm9rZUNvbG9yO1xuICAgIGN0eC5zdHJva2UoKTtcbn0pO1xuXG5kZWZpbmVDYW52YXNSZW5kZXJlcihcbiAgICBcIlNlbGVjdGlvbkJveFwiLFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgX2RyYXdIYW5kbGUgPSBmdW5jdGlvbihjdHgsIHt4LCB5fSwgaGFuZGxlU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGhhbmRsZVNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNmZmZcIjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBoYW5kbGVTaXplLCBoYW5kbGVTaXplKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzAwMFwiO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoeCwgeSwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIF9kcmF3SGFuZGxlKGN0eCwgc2hhcGUuZ2V0VG9wTGVmdEhhbmRsZVJlY3QoKSwgc2hhcGUuaGFuZGxlU2l6ZSk7XG4gICAgICAgICAgICBfZHJhd0hhbmRsZShjdHgsIHNoYXBlLmdldFRvcFJpZ2h0SGFuZGxlUmVjdCgpLCBzaGFwZS5oYW5kbGVTaXplKTtcbiAgICAgICAgICAgIF9kcmF3SGFuZGxlKGN0eCwgc2hhcGUuZ2V0Qm90dG9tTGVmdEhhbmRsZVJlY3QoKSwgc2hhcGUuaGFuZGxlU2l6ZSk7XG4gICAgICAgICAgICBfZHJhd0hhbmRsZShcbiAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgc2hhcGUuZ2V0Qm90dG9tUmlnaHRIYW5kbGVSZWN0KCksXG4gICAgICAgICAgICAgICAgc2hhcGUuaGFuZGxlU2l6ZSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc2hhcGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2JyLnggLSBzaGFwZS5tYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9ici55IC0gc2hhcGUubWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fYnIud2lkdGggKyBzaGFwZS5tYXJnaW4gKiAyLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fYnIuaGVpZ2h0ICsgc2hhcGUubWFyZ2luICogMixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzaGFwZS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCIjMDAwXCI7XG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goWzIsIDRdKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICAgIHNoYXBlLl9ici54IC0gc2hhcGUubWFyZ2luLFxuICAgICAgICAgICAgICAgIHNoYXBlLl9ici55IC0gc2hhcGUubWFyZ2luLFxuICAgICAgICAgICAgICAgIHNoYXBlLl9ici53aWR0aCArIHNoYXBlLm1hcmdpbiAqIDIsXG4gICAgICAgICAgICAgICAgc2hhcGUuX2JyLmhlaWdodCArIHNoYXBlLm1hcmdpbiAqIDIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9O1xuICAgIH0pKCksXG4pO1xuXG5kZWZpbmVDYW52YXNSZW5kZXJlcihcIkltYWdlXCIsIGZ1bmN0aW9uKGN0eCwgc2hhcGUsIHJldHJ5Q2FsbGJhY2spIHtcbiAgICBpZiAoc2hhcGUuaW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgaWYgKHNoYXBlLnNjYWxlID09PSAxKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHNoYXBlLmltYWdlLCBzaGFwZS54LCBzaGFwZS55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIHNoYXBlLmltYWdlLFxuICAgICAgICAgICAgICAgIHNoYXBlLngsXG4gICAgICAgICAgICAgICAgc2hhcGUueSxcbiAgICAgICAgICAgICAgICBzaGFwZS5pbWFnZS53aWR0aCAqIHNoYXBlLnNjYWxlLFxuICAgICAgICAgICAgICAgIHNoYXBlLmltYWdlLmhlaWdodCAqIHNoYXBlLnNjYWxlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmV0cnlDYWxsYmFjaykge1xuICAgICAgICBzaGFwZS5pbWFnZS5vbmxvYWQgPSByZXRyeUNhbGxiYWNrO1xuICAgIH1cbn0pO1xuXG5kZWZpbmVDYW52YXNSZW5kZXJlcihcIkxpbmVcIiwgZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuICAgIGlmIChzaGFwZS54MSA9PT0gc2hhcGUueDIgJiYgc2hhcGUueTEgPT09IHNoYXBlLnkyKSB7XG4gICAgICAgIC8vIGJyb3dzZXIgYmVoYXZpb3IgaXMgbm90IGNvbnNpc3RlbnQgZm9yIHRoaXMgY2FzZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7eDF9ID0gc2hhcGU7XG4gICAgbGV0IHt4Mn0gPSBzaGFwZTtcbiAgICBsZXQge3kxfSA9IHNoYXBlO1xuICAgIGxldCB7eTJ9ID0gc2hhcGU7XG4gICAgaWYgKHNoYXBlLnN0cm9rZVdpZHRoICUgMiAhPT0gMCkge1xuICAgICAgICB4MSArPSAwLjU7XG4gICAgICAgIHgyICs9IDAuNTtcbiAgICAgICAgeTEgKz0gMC41O1xuICAgICAgICB5MiArPSAwLjU7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHNoYXBlLmNvbG9yO1xuICAgIGN0eC5saW5lQ2FwID0gc2hhcGUuY2FwU3R5bGU7XG4gICAgaWYgKHNoYXBlLmRhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHNoYXBlLmRhc2gpO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgaWYgKHNoYXBlLmRhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnJvd1dpZHRoID0gTWF0aC5tYXgoc2hhcGUuc3Ryb2tlV2lkdGggKiAyLjIsIDUpO1xuICAgIGlmIChzaGFwZS5lbmRDYXBTaGFwZXNbMF0pIHtcbiAgICAgICAgbGluZUVuZENhcFNoYXBlc1tzaGFwZS5lbmRDYXBTaGFwZXNbMF1dLmRyYXdUb0NhbnZhcyhcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBNYXRoLmF0YW4yKHkxIC0geTIsIHgxIC0geDIpLFxuICAgICAgICAgICAgYXJyb3dXaWR0aCxcbiAgICAgICAgICAgIHNoYXBlLmNvbG9yLFxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAoc2hhcGUuZW5kQ2FwU2hhcGVzWzFdKSB7XG4gICAgICAgIGxpbmVFbmRDYXBTaGFwZXNbc2hhcGUuZW5kQ2FwU2hhcGVzWzFdXS5kcmF3VG9DYW52YXMoXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICB4MixcbiAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSxcbiAgICAgICAgICAgIGFycm93V2lkdGgsXG4gICAgICAgICAgICBzaGFwZS5jb2xvcixcbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuY29uc3QgX2RyYXdSYXdMaW5lUGF0aCA9IGZ1bmN0aW9uKGN0eCwgcG9pbnRzLCBjbG9zZSwgbGluZUNhcCkge1xuICAgIGlmIChjbG9zZSA9PSBudWxsKSB7XG4gICAgICAgIGNsb3NlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW5lQ2FwID09IG51bGwpIHtcbiAgICAgICAgbGluZUNhcCA9IFwicm91bmRcIjtcbiAgICB9XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHgubGluZUNhcCA9IGxpbmVDYXA7XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBwb2ludHNbMF0uY29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHBvaW50c1swXS5zaXplO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKHBvaW50c1swXS5zaXplICUgMiA9PT0gMCkge1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCArIDAuNSwgcG9pbnRzWzBdLnkgKyAwLjUpO1xuICAgIH1cblxuICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50cy5zbGljZSgxKSkge1xuICAgICAgICBpZiAocG9pbnRzWzBdLnNpemUgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54ICsgMC41LCBwb2ludC55ICsgMC41KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbG9zZSkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxufTtcblxuY29uc3QgZHJhd0xpbmVQYXRoID0gZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuICAgIF9kcmF3UmF3TGluZVBhdGgoY3R4LCBzaGFwZS5zbW9vdGhlZFBvaW50cyk7XG4gICAgY3R4LnN0cm9rZSgpO1xufTtcbmNvbnN0IGRyYXdMaW5lUGF0aExhdGVzdCA9IGZ1bmN0aW9uKGN0eCwgYnVmZmVyQ3R4LCBzaGFwZSkge1xuICAgIGlmIChzaGFwZS50YWlsKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRTdGFydCA9XG4gICAgICAgICAgICBzaGFwZS5zbW9vdGhlZFBvaW50cy5sZW5ndGggLSBzaGFwZS5zZWdtZW50U2l6ZSAqIHNoYXBlLnRhaWxTaXplO1xuICAgICAgICBjb25zdCBkcmF3U3RhcnQgPVxuICAgICAgICAgICAgc2VnbWVudFN0YXJ0IDwgc2hhcGUuc2VnbWVudFNpemUgKiAyID8gMCA6IHNlZ21lbnRTdGFydDtcblxuICAgICAgICBjb25zdCBkcmF3RW5kID0gc2VnbWVudFN0YXJ0ICsgc2hhcGUuc2VnbWVudFNpemUgKyAxO1xuXG4gICAgICAgIF9kcmF3UmF3TGluZVBhdGgoXG4gICAgICAgICAgICBidWZmZXJDdHgsXG4gICAgICAgICAgICBzaGFwZS5zbW9vdGhlZFBvaW50cy5zbGljZShkcmF3U3RhcnQsIGRyYXdFbmQpLFxuICAgICAgICApO1xuICAgICAgICBidWZmZXJDdHguc3Ryb2tlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2RyYXdSYXdMaW5lUGF0aChidWZmZXJDdHgsIHNoYXBlLnNtb290aGVkUG9pbnRzKTtcbiAgICAgICAgYnVmZmVyQ3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5cbmRlZmluZUNhbnZhc1JlbmRlcmVyKFwiTGluZVBhdGhcIiwgZHJhd0xpbmVQYXRoLCBkcmF3TGluZVBhdGhMYXRlc3QpO1xuXG4vLyBzYW1lIGFzIHRoZSBsaW5lIHBhdGggZnVuY3MsIGJ1dCBlcmFzZSBpbnN0ZWFkIG9mIGRyYXdcbmNvbnN0IGRyYXdFcmFzZWRMaW5lUGF0aCA9IGZ1bmN0aW9uKGN0eCwgc2hhcGUpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW91dFwiO1xuICAgIGRyYXdMaW5lUGF0aChjdHgsIHNoYXBlKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufTtcbmNvbnN0IGRyYXdFcmFzZWRMaW5lUGF0aExhdGVzdCA9IGZ1bmN0aW9uKGN0eCwgYnVmZmVyQ3R4LCBzaGFwZSkge1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3V0XCI7XG4gICAgYnVmZmVyQ3R4LnNhdmUoKTtcbiAgICBidWZmZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1vdXRcIjtcblxuICAgIGRyYXdMaW5lUGF0aExhdGVzdChjdHgsIGJ1ZmZlckN0eCwgc2hhcGUpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBidWZmZXJDdHgucmVzdG9yZSgpO1xufTtcblxuZGVmaW5lQ2FudmFzUmVuZGVyZXIoXG4gICAgXCJFcmFzZWRMaW5lUGF0aFwiLFxuICAgIGRyYXdFcmFzZWRMaW5lUGF0aCxcbiAgICBkcmF3RXJhc2VkTGluZVBhdGhMYXRlc3QsXG4pO1xuXG5kZWZpbmVDYW52YXNSZW5kZXJlcihcIlRleHRcIiwgZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuICAgIGlmICghc2hhcGUucmVuZGVyZXIpIHtcbiAgICAgICAgc2hhcGUuX21ha2VSZW5kZXJlcihjdHgpO1xuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gc2hhcGUuY29sb3I7XG4gICAgc2hhcGUucmVuZGVyZXIuZHJhdyhjdHgsIHNoYXBlLngsIHNoYXBlLnkpO1xufSk7XG5cbmRlZmluZUNhbnZhc1JlbmRlcmVyKFwiUG9seWdvblwiLCBmdW5jdGlvbihjdHgsIHNoYXBlKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHNoYXBlLmZpbGxDb2xvcjtcbiAgICBfZHJhd1Jhd0xpbmVQYXRoKGN0eCwgc2hhcGUucG9pbnRzLCBzaGFwZS5pc0Nsb3NlZCwgXCJidXR0XCIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnN0cm9rZSgpO1xufSk7XG5cbmV4cG9ydCB7ZGVmaW5lQ2FudmFzUmVuZGVyZXIsIHJlbmRlclNoYXBlVG9DYW52YXMsIHJlbmRlclNoYXBlVG9Db250ZXh0fTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/canvasRenderer.js\n',
                );

                /***/
            },

        /***/ "./src/defaultOptions.js":
            /*!*******************************!*\
  !*** ./src/defaultOptions.js ***!
  \*******************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools_Pencil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/Pencil */ "./src/tools/Pencil.js");\n\n\nconst defaultOptions = {\n    imageURLPrefix: "lib/img",\n    primaryColor: "hsla(0, 0%, 0%, 1)",\n    secondaryColor: "hsla(0, 0%, 100%, 1)",\n    backgroundColor: "transparent",\n    strokeWidths: [1, 2, 5, 10, 20, 30],\n    defaultStrokeWidth: 5,\n    toolbarPosition: "top",\n    keyboardShortcuts: false,\n    imageSize: {width: "infinite", height: "infinite"},\n    backgroundShapes: [],\n    watermarkImage: null,\n    watermarkScale: 1,\n    zoomMin: 0.2,\n    zoomMax: 4.0,\n    zoomStep: 0.2,\n    snapshot: null,\n    onInit: () => {},\n    tools: [_tools_Pencil__WEBPACK_IMPORTED_MODULE_0__["default"]],\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (defaultOptions);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVmYXVsdE9wdGlvbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdE9wdGlvbnMuanM/ZmZkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGVuY2lsIGZyb20gXCIuL3Rvb2xzL1BlbmNpbFwiO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpbWFnZVVSTFByZWZpeDogXCJsaWIvaW1nXCIsXG4gICAgcHJpbWFyeUNvbG9yOiBcImhzbGEoMCwgMCUsIDAlLCAxKVwiLFxuICAgIHNlY29uZGFyeUNvbG9yOiBcImhzbGEoMCwgMCUsIDEwMCUsIDEpXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgc3Ryb2tlV2lkdGhzOiBbMSwgMiwgNSwgMTAsIDIwLCAzMF0sXG4gICAgZGVmYXVsdFN0cm9rZVdpZHRoOiA1LFxuICAgIHRvb2xiYXJQb3NpdGlvbjogXCJ0b3BcIixcbiAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2UsXG4gICAgaW1hZ2VTaXplOiB7d2lkdGg6IFwiaW5maW5pdGVcIiwgaGVpZ2h0OiBcImluZmluaXRlXCJ9LFxuICAgIGJhY2tncm91bmRTaGFwZXM6IFtdLFxuICAgIHdhdGVybWFya0ltYWdlOiBudWxsLFxuICAgIHdhdGVybWFya1NjYWxlOiAxLFxuICAgIHpvb21NaW46IDAuMixcbiAgICB6b29tTWF4OiA0LjAsXG4gICAgem9vbVN0ZXA6IDAuMixcbiAgICBzbmFwc2hvdDogbnVsbCxcbiAgICBvbkluaXQ6ICgpID0+IHt9LFxuICAgIHRvb2xzOiBbUGVuY2lsXSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRPcHRpb25zO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/defaultOptions.js\n',
                );

                /***/
            },

        /***/ "./src/fontmetrics.js":
            /*!****************************!*\
  !*** ./src/fontmetrics.js ***!
  \****************************/
            /*! no static exports found */
            /***/ function(module, exports) {
                eval(
                    '/**\n  This library rewrites the Canvas2D "measureText" function\n  so that it returns a more complete metrics object.\n  This library is licensed under the MIT (Expat) license,\n  the text for which is included below.\n\n** -----------------------------------------------------------------------------\n\n  CHANGELOG:\n\n    2012-01-21 - Whitespace handling added by Joe Turner\n                 (https://github.com/oampo)\n\n    2015-06-08 - Various hacks added by Steve Johnson\n\n** -----------------------------------------------------------------------------\n\n  Copyright (C) 2011 by Mike "Pomax" Kamermans\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the "Software"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n**/\n(function() {\n    var NAME = "FontMetrics Library";\n    var VERSION = "1-2012.0121.1300";\n\n    var entityMap = {\n        "&": "&amp;",\n        "<": "&lt;",\n        ">": "&gt;",\n        \'"\': "&quot;",\n        "\'": "&#39;",\n        "/": "&#x2F;",\n        "`": "&#x60;",\n        "=": "&#x3D;",\n    };\n\n    function escapeHTML(string) {\n        return String(string).replace(/[&<>"\'`=/]/g, function(s) {\n            return entityMap[s];\n        });\n    }\n\n    // if there is no getComputedStyle, this library won\'t work.\n    if (!document.defaultView.getComputedStyle) {\n        throw "ERROR: \'document.defaultView.getComputedStyle\' not found. This library only works in browsers that can report computed CSS values.";\n    }\n\n    // store the old text metrics function on the Canvas2D prototype\n    CanvasRenderingContext2D.prototype.measureTextWidth =\n        CanvasRenderingContext2D.prototype.measureText;\n\n    /**\n     *  shortcut function for getting computed CSS values\n     */\n    var getCSSValue = function(element, property) {\n        return document.defaultView\n            .getComputedStyle(element, null)\n            .getPropertyValue(property);\n    };\n\n    // debug function\n    var show = function(canvas, ctx, xstart, w, h, metrics) {\n        document.body.appendChild(canvas);\n        ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";\n\n        ctx.beginPath();\n        ctx.moveTo(xstart, 0);\n        ctx.lineTo(xstart, h);\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(xstart + metrics.bounds.maxx, 0);\n        ctx.lineTo(xstart + metrics.bounds.maxx, h);\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(0, h / 2 - metrics.ascent);\n        ctx.lineTo(w, h / 2 - metrics.ascent);\n        ctx.closePath();\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(0, h / 2 + metrics.descent);\n        ctx.lineTo(w, h / 2 + metrics.descent);\n        ctx.closePath();\n        ctx.stroke();\n    };\n\n    /**\n     * The new text metrics function\n     */\n    CanvasRenderingContext2D.prototype.measureText2 = function(\n        textstring,\n        fontSize,\n        fontString,\n    ) {\n        var metrics = this.measureTextWidth(textstring),\n            isSpace = !/\\S/.test(textstring);\n        metrics.fontsize = fontSize;\n\n        // for text lead values, we meaure a multiline text container.\n        var leadDiv = document.createElement("div");\n        leadDiv.style.position = "absolute";\n        leadDiv.style.opacity = 0;\n        leadDiv.style.font = fontString;\n        leadDiv.innerHTML =\n            escapeHTML(textstring) + "<br/>" + escapeHTML(textstring);\n        document.body.appendChild(leadDiv);\n\n        // make some initial guess at the text leading (using the standard TeX ratio)\n        metrics.leading = 1.2 * fontSize;\n\n        // then we try to get the real value from the browser\n        var leadDivHeight = getCSSValue(leadDiv, "height");\n        leadDivHeight = leadDivHeight.replace("px", "");\n        if (leadDivHeight >= fontSize * 2) {\n            metrics.leading = (leadDivHeight / 2) | 0;\n        }\n        document.body.removeChild(leadDiv);\n\n        // if we\'re not dealing with white space, we can compute metrics\n        if (!isSpace) {\n            // Have characters, so measure the text\n            var canvas = document.createElement("canvas");\n            var padding = 100;\n            canvas.width = metrics.width + padding;\n            canvas.height = 3 * fontSize;\n            canvas.style.opacity = 1;\n            canvas.style.font = fontString;\n            var ctx = canvas.getContext("2d");\n            ctx.font = fontString;\n\n            var w = canvas.width,\n                h = canvas.height,\n                baseline = h / 2;\n\n            // Set all canvas pixeldata values to 255, with all the content\n            // data being 0. This lets us scan for data[i] != 255.\n            ctx.fillStyle = "white";\n            ctx.fillRect(-1, -1, w + 2, h + 2);\n            ctx.fillStyle = "black";\n            ctx.fillText(textstring, padding / 2, baseline);\n            var pixelData = ctx.getImageData(0, 0, w, h).data;\n\n            // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n            // consecutive values in the array, rather than stored as 32 bit ints.\n            var i = 0,\n                w4 = w * 4,\n                len = pixelData.length;\n\n            // Finding the ascent uses a normal, forward scanline\n            while (++i < len && pixelData[i] === 255) {}\n            var ascent = (i / w4) | 0;\n\n            // Finding the descent uses a reverse scanline\n            i = len - 1;\n            while (--i > 0 && pixelData[i] === 255) {}\n            var descent = (i / w4) | 0;\n\n            // find the min-x coordinate\n            for (i = 0; i < len && pixelData[i] === 255; ) {\n                i += w4;\n                if (i >= len) {\n                    i = i - len + 4;\n                }\n            }\n            var minx = ((i % w4) / 4) | 0;\n\n            // find the max-x coordinate\n            var step = 1;\n            for (i = len - 3; i >= 0 && pixelData[i] === 255; ) {\n                i -= w4;\n                if (i < 0) {\n                    i = len - 3 - step++ * 4;\n                }\n            }\n            var maxx = ((i % w4) / 4 + 1) | 0;\n\n            // set font metrics\n            metrics.ascent = baseline - ascent;\n            metrics.descent = descent - baseline;\n            metrics.bounds = {\n                minx: minx - padding / 2,\n                maxx: maxx - padding / 2,\n                miny: 0,\n                maxy: descent - ascent,\n            };\n            metrics.height = 1 + (descent - ascent);\n        }\n\n        // if we ARE dealing with whitespace, most values will just be zero.\n        else {\n            // Only whitespace, so we can\'t measure the text\n            metrics.ascent = 0;\n            metrics.descent = 0;\n            metrics.bounds = {\n                minx: 0,\n                maxx: metrics.width, // Best guess\n                miny: 0,\n                maxy: 0,\n            };\n            metrics.height = 0;\n        }\n        return metrics;\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZm9udG1ldHJpY3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZm9udG1ldHJpY3MuanM/N2MzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgVGhpcyBsaWJyYXJ5IHJld3JpdGVzIHRoZSBDYW52YXMyRCBcIm1lYXN1cmVUZXh0XCIgZnVuY3Rpb25cbiAgc28gdGhhdCBpdCByZXR1cm5zIGEgbW9yZSBjb21wbGV0ZSBtZXRyaWNzIG9iamVjdC5cbiAgVGhpcyBsaWJyYXJ5IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKEV4cGF0KSBsaWNlbnNlLFxuICB0aGUgdGV4dCBmb3Igd2hpY2ggaXMgaW5jbHVkZWQgYmVsb3cuXG5cbioqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgQ0hBTkdFTE9HOlxuXG4gICAgMjAxMi0wMS0yMSAtIFdoaXRlc3BhY2UgaGFuZGxpbmcgYWRkZWQgYnkgSm9lIFR1cm5lclxuICAgICAgICAgICAgICAgICAoaHR0cHM6Ly9naXRodWIuY29tL29hbXBvKVxuXG4gICAgMjAxNS0wNi0wOCAtIFZhcmlvdXMgaGFja3MgYWRkZWQgYnkgU3RldmUgSm9obnNvblxuXG4qKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIENvcHlyaWdodCAoQykgMjAxMSBieSBNaWtlIFwiUG9tYXhcIiBLYW1lcm1hbnNcblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAgVEhFIFNPRlRXQVJFLlxuKiovXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIE5BTUUgPSBcIkZvbnRNZXRyaWNzIExpYnJhcnlcIjtcbiAgICB2YXIgVkVSU0lPTiA9IFwiMS0yMDEyLjAxMjEuMTMwMFwiO1xuXG4gICAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICAgICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgICAgIFwiJ1wiOiBcIiYjMzk7XCIsXG4gICAgICAgIFwiL1wiOiBcIiYjeDJGO1wiLFxuICAgICAgICBcImBcIjogXCImI3g2MDtcIixcbiAgICAgICAgXCI9XCI6IFwiJiN4M0Q7XCIsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVzY2FwZUhUTUwoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBnZXRDb21wdXRlZFN0eWxlLCB0aGlzIGxpYnJhcnkgd29uJ3Qgd29yay5cbiAgICBpZiAoIWRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogJ2RvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUnIG5vdCBmb3VuZC4gVGhpcyBsaWJyYXJ5IG9ubHkgd29ya3MgaW4gYnJvd3NlcnMgdGhhdCBjYW4gcmVwb3J0IGNvbXB1dGVkIENTUyB2YWx1ZXMuXCI7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdGhlIG9sZCB0ZXh0IG1ldHJpY3MgZnVuY3Rpb24gb24gdGhlIENhbnZhczJEIHByb3RvdHlwZVxuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUubWVhc3VyZVRleHRXaWR0aCA9XG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUubWVhc3VyZVRleHQ7XG5cbiAgICAvKipcbiAgICAgKiAgc2hvcnRjdXQgZnVuY3Rpb24gZm9yIGdldHRpbmcgY29tcHV0ZWQgQ1NTIHZhbHVlc1xuICAgICAqL1xuICAgIHZhciBnZXRDU1NWYWx1ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0Vmlld1xuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbClcbiAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICB9O1xuXG4gICAgLy8gZGVidWcgZnVuY3Rpb25cbiAgICB2YXIgc2hvdyA9IGZ1bmN0aW9uKGNhbnZhcywgY3R4LCB4c3RhcnQsIHcsIGgsIG1ldHJpY3MpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4c3RhcnQsIDApO1xuICAgICAgICBjdHgubGluZVRvKHhzdGFydCwgaCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4c3RhcnQgKyBtZXRyaWNzLmJvdW5kcy5tYXh4LCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4c3RhcnQgKyBtZXRyaWNzLmJvdW5kcy5tYXh4LCBoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIGggLyAyIC0gbWV0cmljcy5hc2NlbnQpO1xuICAgICAgICBjdHgubGluZVRvKHcsIGggLyAyIC0gbWV0cmljcy5hc2NlbnQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgaCAvIDIgKyBtZXRyaWNzLmRlc2NlbnQpO1xuICAgICAgICBjdHgubGluZVRvKHcsIGggLyAyICsgbWV0cmljcy5kZXNjZW50KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgdGV4dCBtZXRyaWNzIGZ1bmN0aW9uXG4gICAgICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5tZWFzdXJlVGV4dDIgPSBmdW5jdGlvbihcbiAgICAgICAgdGV4dHN0cmluZyxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHJpbmcsXG4gICAgKSB7XG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5tZWFzdXJlVGV4dFdpZHRoKHRleHRzdHJpbmcpLFxuICAgICAgICAgICAgaXNTcGFjZSA9ICEvXFxTLy50ZXN0KHRleHRzdHJpbmcpO1xuICAgICAgICBtZXRyaWNzLmZvbnRzaXplID0gZm9udFNpemU7XG5cbiAgICAgICAgLy8gZm9yIHRleHQgbGVhZCB2YWx1ZXMsIHdlIG1lYXVyZSBhIG11bHRpbGluZSB0ZXh0IGNvbnRhaW5lci5cbiAgICAgICAgdmFyIGxlYWREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBsZWFkRGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBsZWFkRGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICBsZWFkRGl2LnN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICBsZWFkRGl2LmlubmVySFRNTCA9XG4gICAgICAgICAgICBlc2NhcGVIVE1MKHRleHRzdHJpbmcpICsgXCI8YnIvPlwiICsgZXNjYXBlSFRNTCh0ZXh0c3RyaW5nKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsZWFkRGl2KTtcblxuICAgICAgICAvLyBtYWtlIHNvbWUgaW5pdGlhbCBndWVzcyBhdCB0aGUgdGV4dCBsZWFkaW5nICh1c2luZyB0aGUgc3RhbmRhcmQgVGVYIHJhdGlvKVxuICAgICAgICBtZXRyaWNzLmxlYWRpbmcgPSAxLjIgKiBmb250U2l6ZTtcblxuICAgICAgICAvLyB0aGVuIHdlIHRyeSB0byBnZXQgdGhlIHJlYWwgdmFsdWUgZnJvbSB0aGUgYnJvd3NlclxuICAgICAgICB2YXIgbGVhZERpdkhlaWdodCA9IGdldENTU1ZhbHVlKGxlYWREaXYsIFwiaGVpZ2h0XCIpO1xuICAgICAgICBsZWFkRGl2SGVpZ2h0ID0gbGVhZERpdkhlaWdodC5yZXBsYWNlKFwicHhcIiwgXCJcIik7XG4gICAgICAgIGlmIChsZWFkRGl2SGVpZ2h0ID49IGZvbnRTaXplICogMikge1xuICAgICAgICAgICAgbWV0cmljcy5sZWFkaW5nID0gKGxlYWREaXZIZWlnaHQgLyAyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsZWFkRGl2KTtcblxuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIHdoaXRlIHNwYWNlLCB3ZSBjYW4gY29tcHV0ZSBtZXRyaWNzXG4gICAgICAgIGlmICghaXNTcGFjZSkge1xuICAgICAgICAgICAgLy8gSGF2ZSBjaGFyYWN0ZXJzLCBzbyBtZWFzdXJlIHRoZSB0ZXh0XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gMTAwO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gbWV0cmljcy53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmc7XG5cbiAgICAgICAgICAgIHZhciB3ID0gY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgIGggPSBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gaCAvIDI7XG5cbiAgICAgICAgICAgIC8vIFNldCBhbGwgY2FudmFzIHBpeGVsZGF0YSB2YWx1ZXMgdG8gMjU1LCB3aXRoIGFsbCB0aGUgY29udGVudFxuICAgICAgICAgICAgLy8gZGF0YSBiZWluZyAwLiBUaGlzIGxldHMgdXMgc2NhbiBmb3IgZGF0YVtpXSAhPSAyNTUuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KC0xLCAtMSwgdyArIDIsIGggKyAyKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dHN0cmluZywgcGFkZGluZyAvIDIsIGJhc2VsaW5lKTtcbiAgICAgICAgICAgIHZhciBwaXhlbERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpLmRhdGE7XG5cbiAgICAgICAgICAgIC8vIGNhbnZhcyBwaXhlbCBkYXRhIGlzIHcqNCBieSBoKjQsIGJlY2F1c2UgUiwgRywgQiBhbmQgQSBhcmUgc2VwYXJhdGUsXG4gICAgICAgICAgICAvLyBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gdGhlIGFycmF5LCByYXRoZXIgdGhhbiBzdG9yZWQgYXMgMzIgYml0IGludHMuXG4gICAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgICAgdzQgPSB3ICogNCxcbiAgICAgICAgICAgICAgICBsZW4gPSBwaXhlbERhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBGaW5kaW5nIHRoZSBhc2NlbnQgdXNlcyBhIG5vcm1hbCwgZm9yd2FyZCBzY2FubGluZVxuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbiAmJiBwaXhlbERhdGFbaV0gPT09IDI1NSkge31cbiAgICAgICAgICAgIHZhciBhc2NlbnQgPSAoaSAvIHc0KSB8IDA7XG5cbiAgICAgICAgICAgIC8vIEZpbmRpbmcgdGhlIGRlc2NlbnQgdXNlcyBhIHJldmVyc2Ugc2NhbmxpbmVcbiAgICAgICAgICAgIGkgPSBsZW4gLSAxO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+IDAgJiYgcGl4ZWxEYXRhW2ldID09PSAyNTUpIHt9XG4gICAgICAgICAgICB2YXIgZGVzY2VudCA9IChpIC8gdzQpIHwgMDtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWluLXggY29vcmRpbmF0ZVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAmJiBwaXhlbERhdGFbaV0gPT09IDI1NTsgKSB7XG4gICAgICAgICAgICAgICAgaSArPSB3NDtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGkgLSBsZW4gKyA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW54ID0gKChpICUgdzQpIC8gNCkgfCAwO1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtYXgteCBjb29yZGluYXRlXG4gICAgICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAzOyBpID49IDAgJiYgcGl4ZWxEYXRhW2ldID09PSAyNTU7ICkge1xuICAgICAgICAgICAgICAgIGkgLT0gdzQ7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZW4gLSAzIC0gc3RlcCsrICogNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWF4eCA9ICgoaSAlIHc0KSAvIDQgKyAxKSB8IDA7XG5cbiAgICAgICAgICAgIC8vIHNldCBmb250IG1ldHJpY3NcbiAgICAgICAgICAgIG1ldHJpY3MuYXNjZW50ID0gYmFzZWxpbmUgLSBhc2NlbnQ7XG4gICAgICAgICAgICBtZXRyaWNzLmRlc2NlbnQgPSBkZXNjZW50IC0gYmFzZWxpbmU7XG4gICAgICAgICAgICBtZXRyaWNzLmJvdW5kcyA9IHtcbiAgICAgICAgICAgICAgICBtaW54OiBtaW54IC0gcGFkZGluZyAvIDIsXG4gICAgICAgICAgICAgICAgbWF4eDogbWF4eCAtIHBhZGRpbmcgLyAyLFxuICAgICAgICAgICAgICAgIG1pbnk6IDAsXG4gICAgICAgICAgICAgICAgbWF4eTogZGVzY2VudCAtIGFzY2VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZXRyaWNzLmhlaWdodCA9IDEgKyAoZGVzY2VudCAtIGFzY2VudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBBUkUgZGVhbGluZyB3aXRoIHdoaXRlc3BhY2UsIG1vc3QgdmFsdWVzIHdpbGwganVzdCBiZSB6ZXJvLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9ubHkgd2hpdGVzcGFjZSwgc28gd2UgY2FuJ3QgbWVhc3VyZSB0aGUgdGV4dFxuICAgICAgICAgICAgbWV0cmljcy5hc2NlbnQgPSAwO1xuICAgICAgICAgICAgbWV0cmljcy5kZXNjZW50ID0gMDtcbiAgICAgICAgICAgIG1ldHJpY3MuYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIG1pbng6IDAsXG4gICAgICAgICAgICAgICAgbWF4eDogbWV0cmljcy53aWR0aCwgLy8gQmVzdCBndWVzc1xuICAgICAgICAgICAgICAgIG1pbnk6IDAsXG4gICAgICAgICAgICAgICAgbWF4eTogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZXRyaWNzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldHJpY3M7XG4gICAgfTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/fontmetrics.js\n',
                );

                /***/
            },

        /***/ "./src/index.js":
            /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
            /*! exports provided: actions, bindEvents, canvasRenderer, defaultOptions, lineEndCapShapes, LiterallyCanvas, localization, math, renderSnapshotToImage, renderSnapshotToSVG, shapes, svgRenderer, TextRenderer, util, toolsBase, Pencil, default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tools_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/base */ "./src/tools/base.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "toolsBase", function() { return _tools_base__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _tools_Pencil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools/Pencil */ "./src/tools/Pencil.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pencil", function() { return _tools_Pencil__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./src/actions.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "actions", function() { return _actions__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _bindEvents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bindEvents */ "./src/bindEvents.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindEvents", function() { return _bindEvents__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _canvasRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./canvasRenderer */ "./src/canvasRenderer.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "canvasRenderer", function() { return _canvasRenderer__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _defaultOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./defaultOptions */ "./src/defaultOptions.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return _defaultOptions__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n/* harmony import */ var _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lineEndCapShapes */ "./src/lineEndCapShapes.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineEndCapShapes", function() { return _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_6__["default"]; });\n\n/* harmony import */ var _LiterallyCanvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./LiterallyCanvas */ "./src/LiterallyCanvas.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LiterallyCanvas", function() { return _LiterallyCanvas__WEBPACK_IMPORTED_MODULE_7__["default"]; });\n\n/* harmony import */ var _localization__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./localization */ "./src/localization.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "localization", function() { return _localization__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./math */ "./src/math.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _math__WEBPACK_IMPORTED_MODULE_9__["default"]; });\n\n/* harmony import */ var _renderSnapshotToImage__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./renderSnapshotToImage */ "./src/renderSnapshotToImage.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderSnapshotToImage", function() { return _renderSnapshotToImage__WEBPACK_IMPORTED_MODULE_10__["default"]; });\n\n/* harmony import */ var _renderSnapshotToSVG__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./renderSnapshotToSVG */ "./src/renderSnapshotToSVG.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderSnapshotToSVG", function() { return _renderSnapshotToSVG__WEBPACK_IMPORTED_MODULE_11__["default"]; });\n\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./shapes */ "./src/shapes.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "shapes", function() { return _shapes__WEBPACK_IMPORTED_MODULE_12__; });\n/* harmony import */ var _svgRenderer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./svgRenderer */ "./src/svgRenderer.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "svgRenderer", function() { return _svgRenderer__WEBPACK_IMPORTED_MODULE_13__; });\n/* harmony import */ var _TextRenderer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TextRenderer */ "./src/TextRenderer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextRenderer", function() { return _TextRenderer__WEBPACK_IMPORTED_MODULE_14__["default"]; });\n\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util */ "./src/util.js");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _util__WEBPACK_IMPORTED_MODULE_15__; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif (window) {\n    window.LC = {\n        actions: _actions__WEBPACK_IMPORTED_MODULE_2__,\n        bindEvents: _bindEvents__WEBPACK_IMPORTED_MODULE_3__["default"],\n        canvasRenderer: _canvasRenderer__WEBPACK_IMPORTED_MODULE_4__,\n        defaultOptions: _defaultOptions__WEBPACK_IMPORTED_MODULE_5__["default"],\n        lineEndCapShapes: _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_6__["default"],\n        LiterallyCanvas: _LiterallyCanvas__WEBPACK_IMPORTED_MODULE_7__["default"],\n        localization: _localization__WEBPACK_IMPORTED_MODULE_8__,\n        math: _math__WEBPACK_IMPORTED_MODULE_9__["default"],\n        renderSnapshotToImage: _renderSnapshotToImage__WEBPACK_IMPORTED_MODULE_10__["default"],\n        renderSnapshotToSVG: _renderSnapshotToSVG__WEBPACK_IMPORTED_MODULE_11__["default"],\n        shapes: _shapes__WEBPACK_IMPORTED_MODULE_12__,\n        svgRenderer: _svgRenderer__WEBPACK_IMPORTED_MODULE_13__,\n        TextRenderer: _TextRenderer__WEBPACK_IMPORTED_MODULE_14__["default"],\n        util: _util__WEBPACK_IMPORTED_MODULE_15__,\n        toolsBase: _tools_base__WEBPACK_IMPORTED_MODULE_0__,\n        Pencil: _tools_Pencil__WEBPACK_IMPORTED_MODULE_1__["default"],\n    };\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (_LiterallyCanvas__WEBPACK_IMPORTED_MODULE_7__["default"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0b29sc0Jhc2UgZnJvbSBcIi4vdG9vbHMvYmFzZVwiO1xuaW1wb3J0IFBlbmNpbCBmcm9tIFwiLi90b29scy9QZW5jaWxcIjtcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IGJpbmRFdmVudHMgZnJvbSBcIi4vYmluZEV2ZW50c1wiO1xuaW1wb3J0ICogYXMgY2FudmFzUmVuZGVyZXIgZnJvbSBcIi4vY2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCBkZWZhdWx0T3B0aW9ucyBmcm9tIFwiLi9kZWZhdWx0T3B0aW9uc1wiO1xuaW1wb3J0IGxpbmVFbmRDYXBTaGFwZXMgZnJvbSBcIi4vbGluZUVuZENhcFNoYXBlc1wiO1xuaW1wb3J0IExpdGVyYWxseUNhbnZhcyBmcm9tIFwiLi9MaXRlcmFsbHlDYW52YXNcIjtcbmltcG9ydCAqIGFzIGxvY2FsaXphdGlvbiBmcm9tIFwiLi9sb2NhbGl6YXRpb25cIjtcbmltcG9ydCBtYXRoIGZyb20gXCIuL21hdGhcIjtcbmltcG9ydCByZW5kZXJTbmFwc2hvdFRvSW1hZ2UgZnJvbSBcIi4vcmVuZGVyU25hcHNob3RUb0ltYWdlXCI7XG5pbXBvcnQgcmVuZGVyU25hcHNob3RUb1NWRyBmcm9tIFwiLi9yZW5kZXJTbmFwc2hvdFRvU1ZHXCI7XG5pbXBvcnQgKiBhcyBzaGFwZXMgZnJvbSBcIi4vc2hhcGVzXCI7XG5pbXBvcnQgKiBhcyBzdmdSZW5kZXJlciBmcm9tIFwiLi9zdmdSZW5kZXJlclwiO1xuaW1wb3J0IFRleHRSZW5kZXJlciBmcm9tIFwiLi9UZXh0UmVuZGVyZXJcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQge1xuICAgIGFjdGlvbnMsXG4gICAgYmluZEV2ZW50cyxcbiAgICBjYW52YXNSZW5kZXJlcixcbiAgICBkZWZhdWx0T3B0aW9ucyxcbiAgICBsaW5lRW5kQ2FwU2hhcGVzLFxuICAgIExpdGVyYWxseUNhbnZhcyxcbiAgICBsb2NhbGl6YXRpb24sXG4gICAgbWF0aCxcbiAgICByZW5kZXJTbmFwc2hvdFRvSW1hZ2UsXG4gICAgcmVuZGVyU25hcHNob3RUb1NWRyxcbiAgICBzaGFwZXMsXG4gICAgc3ZnUmVuZGVyZXIsXG4gICAgVGV4dFJlbmRlcmVyLFxuICAgIHV0aWwsXG4gICAgdG9vbHNCYXNlLFxuICAgIFBlbmNpbCxcbn07XG5cbmlmICh3aW5kb3cpIHtcbiAgICB3aW5kb3cuTEMgPSB7XG4gICAgICAgIGFjdGlvbnMsXG4gICAgICAgIGJpbmRFdmVudHMsXG4gICAgICAgIGNhbnZhc1JlbmRlcmVyLFxuICAgICAgICBkZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgbGluZUVuZENhcFNoYXBlcyxcbiAgICAgICAgTGl0ZXJhbGx5Q2FudmFzLFxuICAgICAgICBsb2NhbGl6YXRpb24sXG4gICAgICAgIG1hdGgsXG4gICAgICAgIHJlbmRlclNuYXBzaG90VG9JbWFnZSxcbiAgICAgICAgcmVuZGVyU25hcHNob3RUb1NWRyxcbiAgICAgICAgc2hhcGVzLFxuICAgICAgICBzdmdSZW5kZXJlcixcbiAgICAgICAgVGV4dFJlbmRlcmVyLFxuICAgICAgICB1dGlsLFxuICAgICAgICB0b29sc0Jhc2UsXG4gICAgICAgIFBlbmNpbCxcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBMaXRlcmFsbHlDYW52YXM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n',
                );

                /***/
            },

        /***/ "./src/lineEndCapShapes.js":
            /*!*********************************!*\
  !*** ./src/lineEndCapShapes.js ***!
  \*********************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    "__webpack_require__.r(__webpack_exports__);\nconst getPoints = (x, y, angle, width, length) => [\n    {\n        x: x + (Math.cos(angle + Math.PI / 2) * width) / 2,\n        y: y + (Math.sin(angle + Math.PI / 2) * width) / 2,\n    },\n    {\n        x: x + Math.cos(angle) * length,\n        y: y + Math.sin(angle) * length,\n    },\n    {\n        x: x + (Math.cos(angle - Math.PI / 2) * width) / 2,\n        y: y + (Math.sin(angle - Math.PI / 2) * width) / 2,\n    },\n];\n\nconst arrow = {\n    drawToCanvas(ctx, x, y, angle, width, color, length) {\n        if (length == null) {\n            length = 0;\n        }\n        length = length || width;\n\n        ctx.fillStyle = color;\n        ctx.lineWidth = 0;\n        ctx.strokeStyle = \"transparent\";\n        ctx.beginPath();\n        const points = getPoints(x, y, angle, width, length);\n\n        ctx.moveTo(points[0].x, points[0].y);\n        ctx.lineTo(points[1].x, points[1].y);\n        ctx.lineTo(points[2].x, points[2].y);\n        ctx.fill();\n    },\n\n    svg(x, y, angle, width, color, length) {\n        if (length == null) {\n            length = 0;\n        }\n        length = length || width;\n        const points = getPoints(x, y, angle, width, length);\n\n        return `\\\n<polygon \\\nfill='${color}' stroke='none' \\\npoints='${points.map(p => `${p.x},${p.y}`)}' />\\\n`;\n    },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({arrow});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGluZUVuZENhcFNoYXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9saW5lRW5kQ2FwU2hhcGVzLmpzPzcxODAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0UG9pbnRzID0gKHgsIHksIGFuZ2xlLCB3aWR0aCwgbGVuZ3RoKSA9PiBbXG4gICAge1xuICAgICAgICB4OiB4ICsgKE1hdGguY29zKGFuZ2xlICsgTWF0aC5QSSAvIDIpICogd2lkdGgpIC8gMixcbiAgICAgICAgeTogeSArIChNYXRoLnNpbihhbmdsZSArIE1hdGguUEkgLyAyKSAqIHdpZHRoKSAvIDIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG4gICAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGgsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHg6IHggKyAoTWF0aC5jb3MoYW5nbGUgLSBNYXRoLlBJIC8gMikgKiB3aWR0aCkgLyAyLFxuICAgICAgICB5OiB5ICsgKE1hdGguc2luKGFuZ2xlIC0gTWF0aC5QSSAvIDIpICogd2lkdGgpIC8gMixcbiAgICB9LFxuXTtcblxuY29uc3QgYXJyb3cgPSB7XG4gICAgZHJhd1RvQ2FudmFzKGN0eCwgeCwgeSwgYW5nbGUsIHdpZHRoLCBjb2xvciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBsZW5ndGggfHwgd2lkdGg7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gMDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdldFBvaW50cyh4LCB5LCBhbmdsZSwgd2lkdGgsIGxlbmd0aCk7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzJdLngsIHBvaW50c1syXS55KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9LFxuXG4gICAgc3ZnKHgsIHksIGFuZ2xlLCB3aWR0aCwgY29sb3IsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIHx8IHdpZHRoO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBnZXRQb2ludHMoeCwgeSwgYW5nbGUsIHdpZHRoLCBsZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBgXFxcbjxwb2x5Z29uIFxcXG5maWxsPScke2NvbG9yfScgc3Ryb2tlPSdub25lJyBcXFxucG9pbnRzPScke3BvaW50cy5tYXAocCA9PiBgJHtwLnh9LCR7cC55fWApfScgLz5cXFxuYDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge2Fycm93fTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lineEndCapShapes.js\n",
                );

                /***/
            },

        /***/ "./src/localization.js":
            /*!*****************************!*\
  !*** ./src/localization.js ***!
  \*****************************/
            /*! exports provided: localize, _ */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localize", function() { return localize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_", function() { return _; });\nlet strings = {};\n\nconst localize = localStrings => (strings = localStrings);\n\nconst _ = function(string) {\n    const translation = strings[string];\n    return translation || string;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbG9jYWxpemF0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2FsaXphdGlvbi5qcz9mYzE1Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBzdHJpbmdzID0ge307XG5cbmNvbnN0IGxvY2FsaXplID0gbG9jYWxTdHJpbmdzID0+IChzdHJpbmdzID0gbG9jYWxTdHJpbmdzKTtcblxuY29uc3QgXyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gc3RyaW5nc1tzdHJpbmddO1xuICAgIHJldHVybiB0cmFuc2xhdGlvbiB8fCBzdHJpbmc7XG59O1xuXG5leHBvcnQge2xvY2FsaXplLCBffTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/localization.js\n',
                );

                /***/
            },

        /***/ "./src/math.js":
            /*!*********************!*\
  !*** ./src/math.js ***!
  \*********************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\nconst math = {};\n\nmath.toPoly = function(line) {\n    let polyLeft = [];\n    let polyRight = [];\n\n    let index = 0;\n    for (let point of line) {\n        const n = normals(point, _slope(line, index));\n        polyLeft = polyLeft.concat([n[0]]);\n        polyRight = [n[1]].concat(polyRight);\n        index += 1;\n    }\n\n    return polyLeft.concat(polyRight);\n};\n\nvar _slope = function(line, index) {\n    let point;\n    if (line.length < 3) {\n        point = {x: 0, y: 0};\n    }\n    if (index === 0) {\n        point = _slope(line, index + 1);\n    } else if (index === line.length - 1) {\n        point = _slope(line, index - 1);\n    } else {\n        point = math.diff(line[index - 1], line[index + 1]);\n    }\n\n    return point;\n};\n\nmath.diff = (a, b) => ({x: b.x - a.x, y: b.y - a.y});\n\nconst unit = function(vector) {\n    const length = math.len(vector);\n    return {x: vector.x / length, y: vector.y / length};\n};\n\nvar normals = function(p, slope) {\n    slope = unit(slope);\n    slope.x = (slope.x * p.size) / 2;\n    slope.y = (slope.y * p.size) / 2;\n    return [\n        {x: p.x - slope.y, y: p.y + slope.x, color: p.color},\n        {x: p.x + slope.y, y: p.y - slope.x, color: p.color},\n    ];\n};\n\nmath.len = vector => Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n\nmath.scalePositionScalar = function(val, viewportSize, oldScale, newScale) {\n    const oldSize = viewportSize * oldScale;\n    const newSize = viewportSize * newScale;\n    return val + (oldSize - newSize) / 2;\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (math);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoLmpzPzVhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWF0aCA9IHt9O1xuXG5tYXRoLnRvUG9seSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICBsZXQgcG9seUxlZnQgPSBbXTtcbiAgICBsZXQgcG9seVJpZ2h0ID0gW107XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IHBvaW50IG9mIGxpbmUpIHtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbHMocG9pbnQsIF9zbG9wZShsaW5lLCBpbmRleCkpO1xuICAgICAgICBwb2x5TGVmdCA9IHBvbHlMZWZ0LmNvbmNhdChbblswXV0pO1xuICAgICAgICBwb2x5UmlnaHQgPSBbblsxXV0uY29uY2F0KHBvbHlSaWdodCk7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlMZWZ0LmNvbmNhdChwb2x5UmlnaHQpO1xufTtcblxudmFyIF9zbG9wZSA9IGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG4gICAgbGV0IHBvaW50O1xuICAgIGlmIChsaW5lLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcG9pbnQgPSB7eDogMCwgeTogMH07XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBwb2ludCA9IF9zbG9wZShsaW5lLCBpbmRleCArIDEpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICBwb2ludCA9IF9zbG9wZShsaW5lLCBpbmRleCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50ID0gbWF0aC5kaWZmKGxpbmVbaW5kZXggLSAxXSwgbGluZVtpbmRleCArIDFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG5tYXRoLmRpZmYgPSAoYSwgYikgPT4gKHt4OiBiLnggLSBhLngsIHk6IGIueSAtIGEueX0pO1xuXG5jb25zdCB1bml0ID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gbWF0aC5sZW4odmVjdG9yKTtcbiAgICByZXR1cm4ge3g6IHZlY3Rvci54IC8gbGVuZ3RoLCB5OiB2ZWN0b3IueSAvIGxlbmd0aH07XG59O1xuXG52YXIgbm9ybWFscyA9IGZ1bmN0aW9uKHAsIHNsb3BlKSB7XG4gICAgc2xvcGUgPSB1bml0KHNsb3BlKTtcbiAgICBzbG9wZS54ID0gKHNsb3BlLnggKiBwLnNpemUpIC8gMjtcbiAgICBzbG9wZS55ID0gKHNsb3BlLnkgKiBwLnNpemUpIC8gMjtcbiAgICByZXR1cm4gW1xuICAgICAgICB7eDogcC54IC0gc2xvcGUueSwgeTogcC55ICsgc2xvcGUueCwgY29sb3I6IHAuY29sb3J9LFxuICAgICAgICB7eDogcC54ICsgc2xvcGUueSwgeTogcC55IC0gc2xvcGUueCwgY29sb3I6IHAuY29sb3J9LFxuICAgIF07XG59O1xuXG5tYXRoLmxlbiA9IHZlY3RvciA9PiBNYXRoLnNxcnQoTWF0aC5wb3codmVjdG9yLngsIDIpICsgTWF0aC5wb3codmVjdG9yLnksIDIpKTtcblxubWF0aC5zY2FsZVBvc2l0aW9uU2NhbGFyID0gZnVuY3Rpb24odmFsLCB2aWV3cG9ydFNpemUsIG9sZFNjYWxlLCBuZXdTY2FsZSkge1xuICAgIGNvbnN0IG9sZFNpemUgPSB2aWV3cG9ydFNpemUgKiBvbGRTY2FsZTtcbiAgICBjb25zdCBuZXdTaXplID0gdmlld3BvcnRTaXplICogbmV3U2NhbGU7XG4gICAgcmV0dXJuIHZhbCArIChvbGRTaXplIC0gbmV3U2l6ZSkgLyAyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWF0aDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/math.js\n',
                );

                /***/
            },

        /***/ "./src/renderSnapshotToImage.js":
            /*!**************************************!*\
  !*** ./src/renderSnapshotToImage.js ***!
  \**************************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.js");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapes */ "./src/shapes.js");\n\n\n\n// mostly copypasta from LiterallyCanvas.coffee\nconst INFINITE = "infinite";\nconst renderWatermark = function(ctx, image, scale) {\n    if (!image.width) {\n        return;\n    }\n\n    ctx.save();\n    ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);\n    ctx.scale(scale, scale);\n    ctx.drawImage(image, -image.width / 2, -image.height / 2);\n    ctx.restore();\n};\n\nconst renderSnapshotToImage = function(snapshot, opts) {\n    let s;\n    if (opts == null) {\n        opts = {};\n    }\n    if (opts.scale == null) {\n        opts.scale = 1;\n    }\n\n    const shapes = snapshot.shapes.map(s => Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["JSONToShape"])(s));\n    let backgroundShapes = snapshot.backgroundShapes.map(s => Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["JSONToShape"])(s));\n\n    if (opts.margin == null) {\n        opts.margin = {top: 0, right: 0, bottom: 0, left: 0};\n    }\n    const imageSize = snapshot.imageSize || {\n        width: INFINITE,\n        height: INFINITE,\n    };\n\n    const colors = snapshot.colors || {background: "transparent"};\n    const allShapes = shapes.concat(backgroundShapes);\n\n    const watermarkCanvas = document.createElement("canvas");\n    const watermarkCtx = watermarkCanvas.getContext("2d");\n\n    if (opts.rect) {\n        opts.rect.x -= opts.margin.left;\n        opts.rect.y -= opts.margin.top;\n        opts.rect.width += opts.margin.left + opts.margin.right;\n        opts.rect.height += opts.margin.top + opts.margin.bottom;\n    } else {\n        opts.rect = Object(_util__WEBPACK_IMPORTED_MODULE_0__["getDefaultImageRect"])(\n            allShapes.map(s => s.getBoundingRect(watermarkCtx)),\n            imageSize,\n            opts.margin,\n        );\n    }\n\n    watermarkCanvas.width = opts.rect.width * opts.scale;\n    watermarkCanvas.height = opts.rect.height * opts.scale;\n    watermarkCtx.fillStyle = colors.background;\n    watermarkCtx.fillRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);\n\n    if (!(opts.rect.width && opts.rect.height)) {\n        return null;\n    }\n\n    if (opts.watermarkImage) {\n        renderWatermark(watermarkCtx, opts.watermarkImage, opts.watermarkScale);\n    }\n\n    return Object(_util__WEBPACK_IMPORTED_MODULE_0__["combineCanvases"])(\n        watermarkCanvas,\n        Object(_util__WEBPACK_IMPORTED_MODULE_0__["renderShapes"])(backgroundShapes, opts.rect, opts.scale),\n        Object(_util__WEBPACK_IMPORTED_MODULE_0__["renderShapes"])(shapes, opts.rect, opts.scale),\n    );\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (renderSnapshotToImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyU25hcHNob3RUb0ltYWdlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlclNuYXBzaG90VG9JbWFnZS5qcz9lOGUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cmVuZGVyU2hhcGVzLCBjb21iaW5lQ2FudmFzZXMsIGdldERlZmF1bHRJbWFnZVJlY3R9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7SlNPTlRvU2hhcGV9IGZyb20gXCIuL3NoYXBlc1wiO1xuXG4vLyBtb3N0bHkgY29weXBhc3RhIGZyb20gTGl0ZXJhbGx5Q2FudmFzLmNvZmZlZVxuY29uc3QgSU5GSU5JVEUgPSBcImluZmluaXRlXCI7XG5jb25zdCByZW5kZXJXYXRlcm1hcmsgPSBmdW5jdGlvbihjdHgsIGltYWdlLCBzY2FsZSkge1xuICAgIGlmICghaW1hZ2Uud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdHguY2FudmFzLndpZHRoIC8gMiwgY3R4LmNhbnZhcy5oZWlnaHQgLyAyKTtcbiAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtaW1hZ2Uud2lkdGggLyAyLCAtaW1hZ2UuaGVpZ2h0IC8gMik7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbmNvbnN0IHJlbmRlclNuYXBzaG90VG9JbWFnZSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcHRzKSB7XG4gICAgbGV0IHM7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGlmIChvcHRzLnNjYWxlID09IG51bGwpIHtcbiAgICAgICAgb3B0cy5zY2FsZSA9IDE7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzID0gc25hcHNob3Quc2hhcGVzLm1hcChzID0+IEpTT05Ub1NoYXBlKHMpKTtcbiAgICBsZXQgYmFja2dyb3VuZFNoYXBlcyA9IHNuYXBzaG90LmJhY2tncm91bmRTaGFwZXMubWFwKHMgPT4gSlNPTlRvU2hhcGUocykpO1xuXG4gICAgaWYgKG9wdHMubWFyZ2luID09IG51bGwpIHtcbiAgICAgICAgb3B0cy5tYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfTtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VTaXplID0gc25hcHNob3QuaW1hZ2VTaXplIHx8IHtcbiAgICAgICAgd2lkdGg6IElORklOSVRFLFxuICAgICAgICBoZWlnaHQ6IElORklOSVRFLFxuICAgIH07XG5cbiAgICBjb25zdCBjb2xvcnMgPSBzbmFwc2hvdC5jb2xvcnMgfHwge2JhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIn07XG4gICAgY29uc3QgYWxsU2hhcGVzID0gc2hhcGVzLmNvbmNhdChiYWNrZ3JvdW5kU2hhcGVzKTtcblxuICAgIGNvbnN0IHdhdGVybWFya0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3Qgd2F0ZXJtYXJrQ3R4ID0gd2F0ZXJtYXJrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgIGlmIChvcHRzLnJlY3QpIHtcbiAgICAgICAgb3B0cy5yZWN0LnggLT0gb3B0cy5tYXJnaW4ubGVmdDtcbiAgICAgICAgb3B0cy5yZWN0LnkgLT0gb3B0cy5tYXJnaW4udG9wO1xuICAgICAgICBvcHRzLnJlY3Qud2lkdGggKz0gb3B0cy5tYXJnaW4ubGVmdCArIG9wdHMubWFyZ2luLnJpZ2h0O1xuICAgICAgICBvcHRzLnJlY3QuaGVpZ2h0ICs9IG9wdHMubWFyZ2luLnRvcCArIG9wdHMubWFyZ2luLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzLnJlY3QgPSBnZXREZWZhdWx0SW1hZ2VSZWN0KFxuICAgICAgICAgICAgYWxsU2hhcGVzLm1hcChzID0+IHMuZ2V0Qm91bmRpbmdSZWN0KHdhdGVybWFya0N0eCkpLFxuICAgICAgICAgICAgaW1hZ2VTaXplLFxuICAgICAgICAgICAgb3B0cy5tYXJnaW4sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgd2F0ZXJtYXJrQ2FudmFzLndpZHRoID0gb3B0cy5yZWN0LndpZHRoICogb3B0cy5zY2FsZTtcbiAgICB3YXRlcm1hcmtDYW52YXMuaGVpZ2h0ID0gb3B0cy5yZWN0LmhlaWdodCAqIG9wdHMuc2NhbGU7XG4gICAgd2F0ZXJtYXJrQ3R4LmZpbGxTdHlsZSA9IGNvbG9ycy5iYWNrZ3JvdW5kO1xuICAgIHdhdGVybWFya0N0eC5maWxsUmVjdCgwLCAwLCB3YXRlcm1hcmtDYW52YXMud2lkdGgsIHdhdGVybWFya0NhbnZhcy5oZWlnaHQpO1xuXG4gICAgaWYgKCEob3B0cy5yZWN0LndpZHRoICYmIG9wdHMucmVjdC5oZWlnaHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRzLndhdGVybWFya0ltYWdlKSB7XG4gICAgICAgIHJlbmRlcldhdGVybWFyayh3YXRlcm1hcmtDdHgsIG9wdHMud2F0ZXJtYXJrSW1hZ2UsIG9wdHMud2F0ZXJtYXJrU2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lQ2FudmFzZXMoXG4gICAgICAgIHdhdGVybWFya0NhbnZhcyxcbiAgICAgICAgcmVuZGVyU2hhcGVzKGJhY2tncm91bmRTaGFwZXMsIG9wdHMucmVjdCwgb3B0cy5zY2FsZSksXG4gICAgICAgIHJlbmRlclNoYXBlcyhzaGFwZXMsIG9wdHMucmVjdCwgb3B0cy5zY2FsZSksXG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlclNuYXBzaG90VG9JbWFnZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderSnapshotToImage.js\n',
                );

                /***/
            },

        /***/ "./src/renderSnapshotToSVG.js":
            /*!************************************!*\
  !*** ./src/renderSnapshotToSVG.js ***!
  \************************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.js");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapes */ "./src/shapes.js");\n\n\n\nconst INFINITE = "infinite";\n\nconst renderSnapshotToSVG = function(snapshot, opts) {\n    if (opts == null) {\n        opts = {};\n    }\n    const shapes = snapshot.shapes.map(s => Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["JSONToShape"])(s));\n    const backgroundShapes = snapshot.backgroundShapes.map(s => Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["JSONToShape"])(s));\n\n    if (opts.margin == null) {\n        opts.margin = {top: 0, right: 0, bottom: 0, left: 0};\n    }\n    const imageSize = opts.width && opts.height ? { width: opts.width, height: opts.height } : snapshot.imageSize || {\n        width: INFINITE,\n        height: INFINITE,\n    };\n\n    const colors = snapshot.colors || {background: "transparent"};\n    const allShapes = shapes.concat(backgroundShapes);\n\n    const dummyCanvas = document.createElement("canvas");\n    const ctx = dummyCanvas.getContext("2d");\n\n    if (opts.rect) {\n        opts.rect.x -= opts.margin.left;\n        opts.rect.y -= opts.margin.top;\n        opts.rect.width += opts.margin.left + opts.margin.right;\n        opts.rect.height += opts.margin.top + opts.margin.bottom;\n    } else {\n        opts.rect = Object(_util__WEBPACK_IMPORTED_MODULE_0__["getDefaultImageRect"])(\n            allShapes.map(s => s.getBoundingRect(ctx)),\n            imageSize,\n            opts.margin,\n        );\n    }\n\n    return Object(_util__WEBPACK_IMPORTED_MODULE_0__["renderShapesToSVG"])(\n        backgroundShapes.concat(shapes),\n        opts.rect,\n        colors.background,\n    );\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (renderSnapshotToSVG);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVuZGVyU25hcHNob3RUb1NWRy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9yZW5kZXJTbmFwc2hvdFRvU1ZHLmpzP2I0YzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtnZXREZWZhdWx0SW1hZ2VSZWN0LCByZW5kZXJTaGFwZXNUb1NWR30gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IHtKU09OVG9TaGFwZX0gZnJvbSBcIi4vc2hhcGVzXCI7XG5cbmNvbnN0IElORklOSVRFID0gXCJpbmZpbml0ZVwiO1xuXG5jb25zdCByZW5kZXJTbmFwc2hvdFRvU1ZHID0gZnVuY3Rpb24oc25hcHNob3QsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2hhcGVzID0gc25hcHNob3Quc2hhcGVzLm1hcChzID0+IEpTT05Ub1NoYXBlKHMpKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kU2hhcGVzID0gc25hcHNob3QuYmFja2dyb3VuZFNoYXBlcy5tYXAocyA9PiBKU09OVG9TaGFwZShzKSk7XG5cbiAgICBpZiAob3B0cy5tYXJnaW4gPT0gbnVsbCkge1xuICAgICAgICBvcHRzLm1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZVNpemUgPSBvcHRzLndpZHRoICYmIG9wdHMuaGVpZ2h0ID8geyB3aWR0aDogb3B0cy53aWR0aCwgaGVpZ2h0OiBvcHRzLmhlaWdodCB9IDogc25hcHNob3QuaW1hZ2VTaXplIHx8IHtcbiAgICAgICAgd2lkdGg6IElORklOSVRFLFxuICAgICAgICBoZWlnaHQ6IElORklOSVRFLFxuICAgIH07XG5cbiAgICBjb25zdCBjb2xvcnMgPSBzbmFwc2hvdC5jb2xvcnMgfHwge2JhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIn07XG4gICAgY29uc3QgYWxsU2hhcGVzID0gc2hhcGVzLmNvbmNhdChiYWNrZ3JvdW5kU2hhcGVzKTtcblxuICAgIGNvbnN0IGR1bW15Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjb25zdCBjdHggPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBpZiAob3B0cy5yZWN0KSB7XG4gICAgICAgIG9wdHMucmVjdC54IC09IG9wdHMubWFyZ2luLmxlZnQ7XG4gICAgICAgIG9wdHMucmVjdC55IC09IG9wdHMubWFyZ2luLnRvcDtcbiAgICAgICAgb3B0cy5yZWN0LndpZHRoICs9IG9wdHMubWFyZ2luLmxlZnQgKyBvcHRzLm1hcmdpbi5yaWdodDtcbiAgICAgICAgb3B0cy5yZWN0LmhlaWdodCArPSBvcHRzLm1hcmdpbi50b3AgKyBvcHRzLm1hcmdpbi5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy5yZWN0ID0gZ2V0RGVmYXVsdEltYWdlUmVjdChcbiAgICAgICAgICAgIGFsbFNoYXBlcy5tYXAocyA9PiBzLmdldEJvdW5kaW5nUmVjdChjdHgpKSxcbiAgICAgICAgICAgIGltYWdlU2l6ZSxcbiAgICAgICAgICAgIG9wdHMubWFyZ2luLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJTaGFwZXNUb1NWRyhcbiAgICAgICAgYmFja2dyb3VuZFNoYXBlcy5jb25jYXQoc2hhcGVzKSxcbiAgICAgICAgb3B0cy5yZWN0LFxuICAgICAgICBjb2xvcnMuYmFja2dyb3VuZCxcbiAgICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyU25hcHNob3RUb1NWRztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/renderSnapshotToSVG.js\n',
                );

                /***/
            },

        /***/ "./src/shapes.js":
            /*!***********************!*\
  !*** ./src/shapes.js ***!
  \***********************/
            /*! exports provided: defineShape, createShape, JSONToShape, shapeToJSON */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineShape", function() { return defineShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShape", function() { return createShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONToShape", function() { return JSONToShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shapeToJSON", function() { return shapeToJSON; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./src/util.js");\n/* harmony import */ var _TextRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextRenderer */ "./src/TextRenderer.js");\n/* harmony import */ var _canvasRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvasRenderer */ "./src/canvasRenderer.js");\n/* harmony import */ var _svgRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svgRenderer */ "./src/svgRenderer.js");\n/*\n * decaffeinate suggestions:\n * DS201: Simplify complex destructure assignments\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\n\n\n\n\n\nconst shapes = {};\n\nconst defineShape = function(name, props) {\n    // improve Chrome JIT perf by not using arguments object\n    const Shape = function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n        props.constructor.call(\n            this,\n            a,\n            b,\n            c,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o,\n            p,\n        );\n        return this;\n    };\n    Shape.prototype.className = name;\n    Shape.fromJSON = props.fromJSON;\n\n    // support old style of defining canvas drawing methods on shapes\n    if (props.draw) {\n        const legacyDrawFunc = props.draw;\n        const legacyDrawLatestFunc =\n            props.draw ||\n            function(ctx, bufferCtx, retryCallback) {\n                this.draw(ctx, bufferCtx, retryCallback);\n            };\n        const drawFunc = (ctx, shape, retryCallback) =>\n            legacyDrawFunc.call(shape, ctx, retryCallback);\n        const drawLatestFunc = (ctx, bufferCtx, shape, retryCallback) =>\n            legacyDrawLatestFunc.call(shape, ctx, bufferCtx, retryCallback);\n        delete props.draw;\n        if (props.drawLatest) {\n            delete props.drawLatest;\n        }\n\n        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_2__["defineCanvasRenderer"])(name, drawFunc, drawLatestFunc);\n    }\n\n    // support old style of defining SVG drawing methods on shapes\n    if (props.toSVG) {\n        const legacySVGFunc = props.toSVG;\n        const svgFunc = shape => legacySVGFunc.call(shape);\n        delete props.toSVG;\n        Object(_svgRenderer__WEBPACK_IMPORTED_MODULE_3__["defineSVGRenderer"])(name, svgFunc);\n    }\n\n    Shape.prototype.draw = function(ctx, retryCallback) {\n        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_2__["renderShapeToContext"])(ctx, this, {retryCallback});\n    };\n    Shape.prototype.drawLatest = function(ctx, bufferCtx, retryCallback) {\n        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_2__["renderShapeToContext"])(ctx, this, {\n            retryCallback,\n            bufferCtx,\n            shouldOnlyDrawLatest: true,\n        });\n    };\n    Shape.prototype.toSVG = function() {\n        Object(_svgRenderer__WEBPACK_IMPORTED_MODULE_3__["renderShapeToSVG"])(this);\n    };\n\n    for (let k in props) {\n        if (k !== "fromJSON") {\n            Shape.prototype[k] = props[k];\n        }\n    }\n\n    shapes[name] = Shape;\n    return Shape;\n};\n\n// improve Chrome JIT perf by not using arguments object\nconst createShape = function(\n    name,\n    a,\n    b,\n    c,\n    d,\n    e,\n    f,\n    g,\n    h,\n    i,\n    j,\n    k,\n    l,\n    m,\n    n,\n    o,\n    p,\n) {\n    const s = new shapes[name](a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\n    s.id = Object(_util__WEBPACK_IMPORTED_MODULE_0__["getGUID"])();\n    return s;\n};\n\nconst JSONToShape = function({className, data, id}) {\n    if (className in shapes) {\n        const shape = shapes[className].fromJSON(data);\n        if (shape) {\n            if (id) {\n                shape.id = id;\n            }\n            return shape;\n        } else {\n            console.log("Unreadable shape:", className, data);\n            return null;\n        }\n    } else {\n        console.log("Unknown shape:", className, data);\n        return null;\n    }\n};\n\nconst shapeToJSON = shape => ({\n    className: shape.className,\n    data: shape.toJSON(),\n    id: shape.id,\n});\n\n// this fn depends on Point, but LinePathShape depends on it, so it can\'t be\n// moved out of this file yet.\nvar bspline = function(points, order) {\n    if (!order) {\n        return points;\n    }\n    return bspline(_dual(_dual(_refine(points))), order - 1);\n};\n\nvar _refine = function(points) {\n    points = [points[0]].concat(points).concat(Object(_util__WEBPACK_IMPORTED_MODULE_0__["last"])(points));\n    const refined = [];\n\n    let index = 0;\n    for (let point of points) {\n        refined[index * 2] = point;\n        if (points[index + 1]) {\n            refined[index * 2 + 1] = _mid(point, points[index + 1]);\n        }\n        index += 1;\n    }\n\n    return refined;\n};\n\nvar _dual = function(points) {\n    const dualed = [];\n\n    let index = 0;\n    for (let point of points) {\n        if (points[index + 1]) {\n            dualed[index] = _mid(point, points[index + 1]);\n        }\n        index += 1;\n    }\n\n    return dualed;\n};\n\nvar _mid = (a, b) =>\n    createShape("Point", {\n        x: a.x + (b.x - a.x) / 2,\n        y: a.y + (b.y - a.y) / 2,\n        size: a.size + (b.size - a.size) / 2,\n        color: a.color,\n    });\n\ndefineShape("Image", {\n    // TODO: allow resizing/filling\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x = args.x || 0;\n        this.y = args.y || 0;\n        this.scale = args.scale || 1;\n        this.image = args.image || null;\n        this.crossOrigin = (args.image && args.image.crossOrigin) || null;\n    },\n    getBoundingRect() {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.image.width * this.scale,\n            height: this.image.height * this.scale,\n        };\n    },\n    toJSON() {\n        const toJSONData = {\n            x: this.x,\n            y: this.y,\n            imageSrc: this.image.src,\n            imageObject: this.image,\n            scale: this.scale,\n        };\n        if (this.crossOrigin) {\n            toJSONData["crossOrigin"] = this.crossOrigin;\n        }\n        return toJSONData;\n    },\n    fromJSON(data) {\n        let img = null;\n        if (data.imageObject != null ? data.imageObject.width : undefined) {\n            img = data.imageObject;\n        } else {\n            img = new Image();\n            img.src = data.imageSrc;\n            if (data.crossOrigin) {\n                img.crossOrigin = data.crossOrigin;\n            }\n        }\n        return createShape("Image", {\n            x: data.x,\n            y: data.y,\n            image: img,\n            scale: data.scale,\n        });\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x = this.x - moveInfo.xDiff;\n        this.y = this.y - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        this.x = upperLeft.x;\n        this.y = upperLeft.y;\n    },\n});\n\ndefineShape("Rectangle", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x = args.x || 0;\n        this.y = args.y || 0;\n        this.width = args.width || 0;\n        this.height = args.height || 0;\n        this.strokeWidth = args.strokeWidth || 1;\n        this.strokeColor = args.strokeColor || "black";\n        this.fillColor = args.fillColor || "transparent";\n    },\n\n    getBoundingRect() {\n        return {\n            x: this.x - this.strokeWidth / 2,\n            y: this.y - this.strokeWidth / 2,\n            width: this.width + this.strokeWidth,\n            height: this.height + this.strokeWidth,\n        };\n    },\n    toJSON() {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height,\n            strokeWidth: this.strokeWidth,\n            strokeColor: this.strokeColor,\n            fillColor: this.fillColor,\n        };\n    },\n    fromJSON(data) {\n        return createShape("Rectangle", data);\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x = this.x - moveInfo.xDiff;\n        this.y = this.y - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        this.x = upperLeft.x;\n        this.y = upperLeft.y;\n    },\n});\n\n// this is pretty similar to the Rectangle shape. maybe consolidate somehow.\ndefineShape("Ellipse", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x = args.x || 0;\n        this.y = args.y || 0;\n        this.width = args.width || 0;\n        this.height = args.height || 0;\n        this.strokeWidth = args.strokeWidth || 1;\n        this.strokeColor = args.strokeColor || "black";\n        this.fillColor = args.fillColor || "transparent";\n    },\n\n    getBoundingRect() {\n        return {\n            x: this.x - this.strokeWidth / 2,\n            y: this.y - this.strokeWidth / 2,\n            width: this.width + this.strokeWidth,\n            height: this.height + this.strokeWidth,\n        };\n    },\n    toJSON() {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height,\n            strokeWidth: this.strokeWidth,\n            strokeColor: this.strokeColor,\n            fillColor: this.fillColor,\n        };\n    },\n    fromJSON(data) {\n        return createShape("Ellipse", data);\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x = this.x - moveInfo.xDiff;\n        this.y = this.y - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        this.x = upperLeft.x;\n        this.y = upperLeft.y;\n    },\n});\n\ndefineShape("Line", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x1 = args.x1 || 0;\n        this.y1 = args.y1 || 0;\n        this.x2 = args.x2 || 0;\n        this.y2 = args.y2 || 0;\n        this.strokeWidth = args.strokeWidth || 1;\n        this.color = args.color || "black";\n        this.capStyle = args.capStyle || "round";\n        this.endCapShapes = args.endCapShapes || [null, null];\n        this.dash = args.dash || null;\n    },\n\n    getBoundingRect() {\n        return {\n            x: Math.min(this.x1, this.x2) - this.strokeWidth / 2,\n            y: Math.min(this.y1, this.y2) - this.strokeWidth / 2,\n            width: Math.abs(this.x2 - this.x1) + this.strokeWidth / 2,\n            height: Math.abs(this.y2 - this.y1) + this.strokeWidth / 2,\n        };\n    },\n    toJSON() {\n        return {\n            x1: this.x1,\n            y1: this.y1,\n            x2: this.x2,\n            y2: this.y2,\n            strokeWidth: this.strokeWidth,\n            color: this.color,\n            capStyle: this.capStyle,\n            dash: this.dash,\n            endCapShapes: this.endCapShapes,\n        };\n    },\n    fromJSON(data) {\n        return createShape("Line", data);\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x1 = this.x1 - moveInfo.xDiff;\n        this.y1 = this.y1 - moveInfo.yDiff;\n        this.x2 = this.x2 - moveInfo.xDiff;\n        this.y2 = this.y2 - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        const br = this.getBoundingRect();\n        const xDiff = br.x - upperLeft.x;\n        const yDiff = br.y - upperLeft.y;\n        this.move({xDiff, yDiff});\n    },\n});\n\n// returns false if no points because there are no points to share style\nconst _doAllPointsShareStyle = function(points) {\n    if (!points.length) {\n        return false;\n    }\n    const {size} = points[0];\n    const {color} = points[0];\n    for (let point of points) {\n        if (point.size !== size || point.color !== color) {\n            console.log(size, color, point.size, point.color);\n        }\n        if (point.size !== size || point.color !== color) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst _createLinePathFromData = function(shapeName, data) {\n    let x, y;\n    let points = null;\n    if (data.points) {\n        points = data.points.map(pointData => JSONToShape(pointData));\n    } else if (data.pointCoordinatePairs) {\n        points = data.pointCoordinatePairs.map(([x, y]) =>\n            JSONToShape({\n                className: "Point",\n                data: {\n                    x,\n                    y,\n                    size: data.pointSize,\n                    color: data.pointColor,\n                    smooth: data.smooth,\n                },\n            }),\n        );\n    }\n\n    let smoothedPoints = null;\n    if (data.smoothedPointCoordinatePairs) {\n        smoothedPoints = data.smoothedPointCoordinatePairs.map(([x, y]) =>\n            JSONToShape({\n                className: "Point",\n                data: {\n                    x,\n                    y,\n                    size: data.pointSize,\n                    color: data.pointColor,\n                    smooth: data.smooth,\n                },\n            }),\n        );\n    }\n\n    if (!points[0]) {\n        return null;\n    }\n    return createShape(shapeName, {\n        points,\n        smoothedPoints,\n        order: data.order,\n        tailSize: data.tailSize,\n        smooth: data.smooth,\n    });\n};\n\nconst linePathFuncs = {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        const points = args.points || [];\n        this.order = args.order || 3;\n        this.tailSize = args.tailSize || 3;\n        this.smooth = "smooth" in args ? args.smooth : true;\n\n        // The number of smoothed points generated for each point added\n        this.segmentSize = Math.pow(2, this.order);\n\n        // The number of points used to calculate the bspline to the newest point\n        this.sampleSize = this.tailSize + 1;\n\n        if (args.smoothedPoints) {\n            this.points = args.points;\n            this.smoothedPoints = args.smoothedPoints;\n        } else {\n            this.points = [];\n            points.map(point => this.addPoint(point));\n        }\n    },\n\n    getBoundingRect() {\n        return Object(_util__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(\n            this.points.map(p => ({\n                x: p.x - p.size / 2,\n                y: p.y - p.size / 2,\n                width: p.size,\n                height: p.size,\n            })),\n        );\n    },\n\n    toJSON() {\n        if (_doAllPointsShareStyle(this.points)) {\n            return {\n                order: this.order,\n                tailSize: this.tailSize,\n                smooth: this.smooth,\n                pointCoordinatePairs: this.points.map(point => [\n                    point.x,\n                    point.y,\n                ]),\n                smoothedPointCoordinatePairs: this.smoothedPoints.map(point => [\n                    point.x,\n                    point.y,\n                ]),\n                pointSize: this.points[0].size,\n                pointColor: this.points[0].color,\n            };\n        } else {\n            return {\n                order: this.order,\n                tailSize: this.tailSize,\n                smooth: this.smooth,\n                points: this.points.map(p => shapeToJSON(p)),\n            };\n        }\n    },\n\n    fromJSON(data) {\n        return _createLinePathFromData("LinePath", data);\n    },\n\n    addPoint(point) {\n        this.points.push(point);\n\n        if (!this.smooth) {\n            this.smoothedPoints = this.points;\n            return;\n        }\n\n        if (!this.smoothedPoints || this.points.length < this.sampleSize) {\n            this.smoothedPoints = bspline(this.points, this.order);\n        } else {\n            this.tail = Object(_util__WEBPACK_IMPORTED_MODULE_0__["last"])(\n                bspline(Object(_util__WEBPACK_IMPORTED_MODULE_0__["last"])(this.points, this.sampleSize), this.order),\n                this.segmentSize * this.tailSize,\n            );\n\n            // Remove the last @tailSize - 1 segments from @smoothedPoints\n            // then concat the tail. This is done because smoothed points\n            // close to the end of the path will change as new points are\n            // added.\n            this.smoothedPoints = this.smoothedPoints\n                .slice(\n                    0,\n                    this.smoothedPoints.length -\n                        this.segmentSize * (this.tailSize - 1),\n                )\n                .concat(this.tail);\n        }\n    },\n\n    move(moveInfo) {\n        let pts;\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        if (!this.smooth) {\n            pts = this.points;\n        } else {\n            pts = this.smoothedPoints;\n        }\n\n        for (let pt of pts) {\n            pt.move(moveInfo);\n        }\n\n        this.points = this.smoothedPoints;\n    },\n\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        const br = this.getBoundingRect();\n        const xDiff = br.x - upperLeft.x;\n        const yDiff = br.y - upperLeft.y;\n        this.move({xDiff, yDiff});\n    },\n};\n\nconst LinePath = defineShape("LinePath", linePathFuncs);\n\ndefineShape("ErasedLinePath", {\n    constructor: linePathFuncs.constructor,\n    toJSON: linePathFuncs.toJSON,\n    addPoint: linePathFuncs.addPoint,\n    getBoundingRect: linePathFuncs.getBoundingRect,\n\n    fromJSON(data) {\n        return _createLinePathFromData("ErasedLinePath", data);\n    },\n});\n\n// this is currently just used for LinePath/ErasedLinePath internal storage.\ndefineShape("Point", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x = args.x || 0;\n        this.y = args.y || 0;\n        this.size = args.size || 0;\n        this.color = args.color || "";\n    },\n    getBoundingRect() {\n        return {\n            x: this.x - this.size / 2,\n            y: this.y - this.size / 2,\n            width: this.size,\n            height: this.size,\n        };\n    },\n    toJSON() {\n        return {x: this.x, y: this.y, size: this.size, color: this.color};\n    },\n    fromJSON(data) {\n        return createShape("Point", data);\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x = this.x - moveInfo.xDiff;\n        this.y = this.y - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        this.x = upperLeft.x;\n        this.y = upperLeft.y;\n    },\n});\n\ndefineShape("Polygon", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.points = args.points;\n        this.fillColor = args.fillColor || "white";\n        this.strokeColor = args.strokeColor || "black";\n        this.strokeWidth = args.strokeWidth;\n        this.dash = args.dash || null;\n\n        if (args.isClosed == null) {\n            args.isClosed = true;\n        }\n        this.isClosed = args.isClosed;\n\n        // ignore point values\n        this.points.forEach(point => {\n            point.color = this.strokeColor;\n            point.size = this.strokeWidth;\n        });\n    },\n\n    addPoint(x, y) {\n        this.points.push(createShape("Point", {x, y}));\n    },\n\n    getBoundingRect() {\n        return Object(_util__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(this.points.map(p => p.getBoundingRect()));\n    },\n\n    toJSON() {\n        return {\n            strokeWidth: this.strokeWidth,\n            fillColor: this.fillColor,\n            strokeColor: this.strokeColor,\n            dash: this.dash,\n            isClosed: this.isClosed,\n            pointCoordinatePairs: this.points.map(p => [p.x, p.y]),\n        };\n    },\n    fromJSON(data) {\n        data.points = data.pointCoordinatePairs.map(function(...args) {\n            const [x, y] = args[0];\n            return createShape("Point", {\n                x,\n                y,\n                size: data.strokeWidth,\n                color: data.strokeColor,\n            });\n        });\n        return createShape("Polygon", data);\n    },\n\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.points.map(pt => pt.move(moveInfo));\n    },\n\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        const br = this.getBoundingRect();\n        const xDiff = br.x - upperLeft.x;\n        const yDiff = br.y - upperLeft.y;\n        this.move({xDiff, yDiff});\n    },\n});\n\ndefineShape("Text", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.x = args.x || 0;\n        this.y = args.y || 0;\n        this.v = args.v || 0; // version (<1 needs position repaired)\n        this.text = args.text || "";\n        this.color = args.color || "black";\n        this.font = args.font || "18px sans-serif";\n        this.forcedWidth = args.forcedWidth || null;\n        this.forcedHeight = args.forcedHeight || null;\n    },\n\n    _makeRenderer(ctx) {\n        ctx.lineHeight = 1.2;\n        this.renderer = new _TextRenderer__WEBPACK_IMPORTED_MODULE_1__["default"](\n            ctx,\n            this.text,\n            this.font,\n            this.forcedWidth,\n            this.forcedHeight,\n        );\n\n        if (this.v < 1) {\n            console.log("repairing baseline");\n            this.v = 1;\n            this.x -= this.renderer.metrics.bounds.minx;\n            this.y -=\n                this.renderer.metrics.leading - this.renderer.metrics.descent;\n        }\n    },\n\n    setText(text) {\n        this.text = text;\n        this.renderer = null;\n    },\n\n    setFont(font) {\n        this.font = font;\n        this.renderer = null;\n    },\n\n    setPosition(x, y) {\n        this.x = x;\n        this.y = y;\n    },\n\n    setSize(forcedWidth, forcedHeight) {\n        this.forcedWidth = Math.max(forcedWidth, 0);\n        this.forcedHeight = Math.max(forcedHeight, 0);\n        this.renderer = null;\n    },\n\n    enforceMaxBoundingRect(lc) {\n        const br = this.getBoundingRect(lc.ctx);\n        const lcBoundingRect = {\n            x: -lc.position.x / lc.scale,\n            y: -lc.position.y / lc.scale,\n            width: lc.canvas.width / lc.scale,\n            height: lc.canvas.height / lc.scale,\n        };\n        // really just enforce max width\n        if (br.x + br.width > lcBoundingRect.x + lcBoundingRect.width) {\n            const dx = br.x - lcBoundingRect.x;\n            this.forcedWidth = lcBoundingRect.width - dx - 10;\n            this.renderer = null;\n        }\n    },\n\n    getBoundingRect(ctx, isEditing) {\n        // if isEditing == true, add X padding to account for carat\n        if (isEditing == null) {\n            isEditing = false;\n        }\n        if (!this.renderer) {\n            if (ctx) {\n                this._makeRenderer(ctx);\n            } else {\n                throw "Must pass ctx if text hasn\'t been rendered yet";\n            }\n        }\n        return {\n            x: Math.floor(this.x),\n            y: Math.floor(this.y),\n            width: Math.ceil(this.renderer.getWidth(true)),\n            height: Math.ceil(this.renderer.getHeight()),\n        };\n    },\n    toJSON() {\n        return {\n            x: this.x,\n            y: this.y,\n            text: this.text,\n            color: this.color,\n            font: this.font,\n            forcedWidth: this.forcedWidth,\n            forcedHeight: this.forcedHeight,\n            v: this.v,\n        };\n    },\n    fromJSON(data) {\n        return createShape("Text", data);\n    },\n    move(moveInfo) {\n        if (moveInfo == null) {\n            moveInfo = {};\n        }\n        this.x = this.x - moveInfo.xDiff;\n        this.y = this.y - moveInfo.yDiff;\n    },\n    setUpperLeft(upperLeft) {\n        if (upperLeft == null) {\n            upperLeft = {};\n        }\n        this.x = upperLeft.x;\n        this.y = upperLeft.y;\n    },\n});\n\ndefineShape("SelectionBox", {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        this.shape = args.shape;\n        if (args.handleSize != null) {\n            this.handleSize = args.handleSize;\n        } else {\n            this.handleSize = 10;\n        }\n        this.margin = 4;\n        this.backgroundColor = args.backgroundColor || null;\n        this._br = this.shape.getBoundingRect(args.ctx);\n    },\n\n    toJSON() {\n        return {\n            shape: shapeToJSON(this.shape),\n            backgroundColor: this.backgroundColor,\n        };\n    },\n    fromJSON({shape, handleSize, margin, backgroundColor}) {\n        return createShape("SelectionBox", {\n            shape: JSONToShape(shape),\n            backgroundColor,\n        });\n    },\n\n    getTopLeftHandleRect() {\n        return {\n            x: this._br.x - this.handleSize - this.margin,\n            y: this._br.y - this.handleSize - this.margin,\n            width: this.handleSize,\n            height: this.handleSize,\n        };\n    },\n\n    getBottomLeftHandleRect() {\n        return {\n            x: this._br.x - this.handleSize - this.margin,\n            y: this._br.y + this._br.height + this.margin,\n            width: this.handleSize,\n            height: this.handleSize,\n        };\n    },\n\n    getTopRightHandleRect() {\n        return {\n            x: this._br.x + this._br.width + this.margin,\n            y: this._br.y - this.handleSize - this.margin,\n            width: this.handleSize,\n            height: this.handleSize,\n        };\n    },\n\n    getBottomRightHandleRect() {\n        return {\n            x: this._br.x + this._br.width + this.margin,\n            y: this._br.y + this._br.height + this.margin,\n            width: this.handleSize,\n            height: this.handleSize,\n        };\n    },\n\n    getBoundingRect() {\n        return {\n            x: this._br.x - this.margin,\n            y: this._br.y - this.margin,\n            width: this._br.width + this.margin * 2,\n            height: this._br.height + this.margin * 2,\n        };\n    },\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2hhcGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXBlcy5qcz9mODU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBkZWNhZmZlaW5hdGUgc3VnZ2VzdGlvbnM6XG4gKiBEUzIwMTogU2ltcGxpZnkgY29tcGxleCBkZXN0cnVjdHVyZSBhc3NpZ25tZW50c1xuICogRnVsbCBkb2NzOiBodHRwczovL2dpdGh1Yi5jb20vZGVjYWZmZWluYXRlL2RlY2FmZmVpbmF0ZS9ibG9iL21hc3Rlci9kb2NzL3N1Z2dlc3Rpb25zLm1kXG4gKi9cblxuaW1wb3J0IHtnZXRHVUlELCBsYXN0LCBnZXRCb3VuZGluZ1JlY3R9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCBUZXh0UmVuZGVyZXIgZnJvbSBcIi4vVGV4dFJlbmRlcmVyXCI7XG5pbXBvcnQge2RlZmluZUNhbnZhc1JlbmRlcmVyLCByZW5kZXJTaGFwZVRvQ29udGV4dH0gZnJvbSBcIi4vY2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCB7ZGVmaW5lU1ZHUmVuZGVyZXIsIHJlbmRlclNoYXBlVG9TVkd9IGZyb20gXCIuL3N2Z1JlbmRlcmVyXCI7XG5cbmNvbnN0IHNoYXBlcyA9IHt9O1xuXG5jb25zdCBkZWZpbmVTaGFwZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3BzKSB7XG4gICAgLy8gaW1wcm92ZSBDaHJvbWUgSklUIHBlcmYgYnkgbm90IHVzaW5nIGFyZ3VtZW50cyBvYmplY3RcbiAgICBjb25zdCBTaGFwZSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8sIHApIHtcbiAgICAgICAgcHJvcHMuY29uc3RydWN0b3IuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBwLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNoYXBlLnByb3RvdHlwZS5jbGFzc05hbWUgPSBuYW1lO1xuICAgIFNoYXBlLmZyb21KU09OID0gcHJvcHMuZnJvbUpTT047XG5cbiAgICAvLyBzdXBwb3J0IG9sZCBzdHlsZSBvZiBkZWZpbmluZyBjYW52YXMgZHJhd2luZyBtZXRob2RzIG9uIHNoYXBlc1xuICAgIGlmIChwcm9wcy5kcmF3KSB7XG4gICAgICAgIGNvbnN0IGxlZ2FjeURyYXdGdW5jID0gcHJvcHMuZHJhdztcbiAgICAgICAgY29uc3QgbGVnYWN5RHJhd0xhdGVzdEZ1bmMgPVxuICAgICAgICAgICAgcHJvcHMuZHJhdyB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oY3R4LCBidWZmZXJDdHgsIHJldHJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoY3R4LCBidWZmZXJDdHgsIHJldHJ5Q2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZHJhd0Z1bmMgPSAoY3R4LCBzaGFwZSwgcmV0cnlDYWxsYmFjaykgPT5cbiAgICAgICAgICAgIGxlZ2FjeURyYXdGdW5jLmNhbGwoc2hhcGUsIGN0eCwgcmV0cnlDYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IGRyYXdMYXRlc3RGdW5jID0gKGN0eCwgYnVmZmVyQ3R4LCBzaGFwZSwgcmV0cnlDYWxsYmFjaykgPT5cbiAgICAgICAgICAgIGxlZ2FjeURyYXdMYXRlc3RGdW5jLmNhbGwoc2hhcGUsIGN0eCwgYnVmZmVyQ3R4LCByZXRyeUNhbGxiYWNrKTtcbiAgICAgICAgZGVsZXRlIHByb3BzLmRyYXc7XG4gICAgICAgIGlmIChwcm9wcy5kcmF3TGF0ZXN0KSB7XG4gICAgICAgICAgICBkZWxldGUgcHJvcHMuZHJhd0xhdGVzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmluZUNhbnZhc1JlbmRlcmVyKG5hbWUsIGRyYXdGdW5jLCBkcmF3TGF0ZXN0RnVuYyk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCBvbGQgc3R5bGUgb2YgZGVmaW5pbmcgU1ZHIGRyYXdpbmcgbWV0aG9kcyBvbiBzaGFwZXNcbiAgICBpZiAocHJvcHMudG9TVkcpIHtcbiAgICAgICAgY29uc3QgbGVnYWN5U1ZHRnVuYyA9IHByb3BzLnRvU1ZHO1xuICAgICAgICBjb25zdCBzdmdGdW5jID0gc2hhcGUgPT4gbGVnYWN5U1ZHRnVuYy5jYWxsKHNoYXBlKTtcbiAgICAgICAgZGVsZXRlIHByb3BzLnRvU1ZHO1xuICAgICAgICBkZWZpbmVTVkdSZW5kZXJlcihuYW1lLCBzdmdGdW5jKTtcbiAgICB9XG5cbiAgICBTaGFwZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgcmV0cnlDYWxsYmFjaykge1xuICAgICAgICByZW5kZXJTaGFwZVRvQ29udGV4dChjdHgsIHRoaXMsIHtyZXRyeUNhbGxiYWNrfSk7XG4gICAgfTtcbiAgICBTaGFwZS5wcm90b3R5cGUuZHJhd0xhdGVzdCA9IGZ1bmN0aW9uKGN0eCwgYnVmZmVyQ3R4LCByZXRyeUNhbGxiYWNrKSB7XG4gICAgICAgIHJlbmRlclNoYXBlVG9Db250ZXh0KGN0eCwgdGhpcywge1xuICAgICAgICAgICAgcmV0cnlDYWxsYmFjayxcbiAgICAgICAgICAgIGJ1ZmZlckN0eCxcbiAgICAgICAgICAgIHNob3VsZE9ubHlEcmF3TGF0ZXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNoYXBlLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZW5kZXJTaGFwZVRvU1ZHKHRoaXMpO1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBrIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChrICE9PSBcImZyb21KU09OXCIpIHtcbiAgICAgICAgICAgIFNoYXBlLnByb3RvdHlwZVtrXSA9IHByb3BzW2tdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hhcGVzW25hbWVdID0gU2hhcGU7XG4gICAgcmV0dXJuIFNoYXBlO1xufTtcblxuLy8gaW1wcm92ZSBDaHJvbWUgSklUIHBlcmYgYnkgbm90IHVzaW5nIGFyZ3VtZW50cyBvYmplY3RcbmNvbnN0IGNyZWF0ZVNoYXBlID0gZnVuY3Rpb24oXG4gICAgbmFtZSxcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZixcbiAgICBnLFxuICAgIGgsXG4gICAgaSxcbiAgICBqLFxuICAgIGssXG4gICAgbCxcbiAgICBtLFxuICAgIG4sXG4gICAgbyxcbiAgICBwLFxuKSB7XG4gICAgY29uc3QgcyA9IG5ldyBzaGFwZXNbbmFtZV0oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCk7XG4gICAgcy5pZCA9IGdldEdVSUQoKTtcbiAgICByZXR1cm4gcztcbn07XG5cbmNvbnN0IEpTT05Ub1NoYXBlID0gZnVuY3Rpb24oe2NsYXNzTmFtZSwgZGF0YSwgaWR9KSB7XG4gICAgaWYgKGNsYXNzTmFtZSBpbiBzaGFwZXMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBzaGFwZXNbY2xhc3NOYW1lXS5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5pZCA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbnJlYWRhYmxlIHNoYXBlOlwiLCBjbGFzc05hbWUsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gc2hhcGU6XCIsIGNsYXNzTmFtZSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmNvbnN0IHNoYXBlVG9KU09OID0gc2hhcGUgPT4gKHtcbiAgICBjbGFzc05hbWU6IHNoYXBlLmNsYXNzTmFtZSxcbiAgICBkYXRhOiBzaGFwZS50b0pTT04oKSxcbiAgICBpZDogc2hhcGUuaWQsXG59KTtcblxuLy8gdGhpcyBmbiBkZXBlbmRzIG9uIFBvaW50LCBidXQgTGluZVBhdGhTaGFwZSBkZXBlbmRzIG9uIGl0LCBzbyBpdCBjYW4ndCBiZVxuLy8gbW92ZWQgb3V0IG9mIHRoaXMgZmlsZSB5ZXQuXG52YXIgYnNwbGluZSA9IGZ1bmN0aW9uKHBvaW50cywgb3JkZXIpIHtcbiAgICBpZiAoIW9yZGVyKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIHJldHVybiBic3BsaW5lKF9kdWFsKF9kdWFsKF9yZWZpbmUocG9pbnRzKSkpLCBvcmRlciAtIDEpO1xufTtcblxudmFyIF9yZWZpbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICBwb2ludHMgPSBbcG9pbnRzWzBdXS5jb25jYXQocG9pbnRzKS5jb25jYXQobGFzdChwb2ludHMpKTtcbiAgICBjb25zdCByZWZpbmVkID0gW107XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICByZWZpbmVkW2luZGV4ICogMl0gPSBwb2ludDtcbiAgICAgICAgaWYgKHBvaW50c1tpbmRleCArIDFdKSB7XG4gICAgICAgICAgICByZWZpbmVkW2luZGV4ICogMiArIDFdID0gX21pZChwb2ludCwgcG9pbnRzW2luZGV4ICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmluZWQ7XG59O1xuXG52YXIgX2R1YWwgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICBjb25zdCBkdWFsZWQgPSBbXTtcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgIGlmIChwb2ludHNbaW5kZXggKyAxXSkge1xuICAgICAgICAgICAgZHVhbGVkW2luZGV4XSA9IF9taWQocG9pbnQsIHBvaW50c1tpbmRleCArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBkdWFsZWQ7XG59O1xuXG52YXIgX21pZCA9IChhLCBiKSA9PlxuICAgIGNyZWF0ZVNoYXBlKFwiUG9pbnRcIiwge1xuICAgICAgICB4OiBhLnggKyAoYi54IC0gYS54KSAvIDIsXG4gICAgICAgIHk6IGEueSArIChiLnkgLSBhLnkpIC8gMixcbiAgICAgICAgc2l6ZTogYS5zaXplICsgKGIuc2l6ZSAtIGEuc2l6ZSkgLyAyLFxuICAgICAgICBjb2xvcjogYS5jb2xvcixcbiAgICB9KTtcblxuZGVmaW5lU2hhcGUoXCJJbWFnZVwiLCB7XG4gICAgLy8gVE9ETzogYWxsb3cgcmVzaXppbmcvZmlsbGluZ1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IGFyZ3MueCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSBhcmdzLnkgfHwgMDtcbiAgICAgICAgdGhpcy5zY2FsZSA9IGFyZ3Muc2NhbGUgfHwgMTtcbiAgICAgICAgdGhpcy5pbWFnZSA9IGFyZ3MuaW1hZ2UgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IChhcmdzLmltYWdlICYmIGFyZ3MuaW1hZ2UuY3Jvc3NPcmlnaW4pIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5pbWFnZS53aWR0aCAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaW1hZ2UuaGVpZ2h0ICogdGhpcy5zY2FsZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgdG9KU09ORGF0YSA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgIGltYWdlU3JjOiB0aGlzLmltYWdlLnNyYyxcbiAgICAgICAgICAgIGltYWdlT2JqZWN0OiB0aGlzLmltYWdlLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICB0b0pTT05EYXRhW1wiY3Jvc3NPcmlnaW5cIl0gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0pTT05EYXRhO1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICBsZXQgaW1nID0gbnVsbDtcbiAgICAgICAgaWYgKGRhdGEuaW1hZ2VPYmplY3QgIT0gbnVsbCA/IGRhdGEuaW1hZ2VPYmplY3Qud2lkdGggOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltZyA9IGRhdGEuaW1hZ2VPYmplY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBkYXRhLmltYWdlU3JjO1xuICAgICAgICAgICAgaWYgKGRhdGEuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBkYXRhLmNyb3NzT3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFwZShcIkltYWdlXCIsIHtcbiAgICAgICAgICAgIHg6IGRhdGEueCxcbiAgICAgICAgICAgIHk6IGRhdGEueSxcbiAgICAgICAgICAgIGltYWdlOiBpbWcsXG4gICAgICAgICAgICBzY2FsZTogZGF0YS5zY2FsZSxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBtb3ZlKG1vdmVJbmZvKSB7XG4gICAgICAgIGlmIChtb3ZlSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3ZlSW5mbyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCAtIG1vdmVJbmZvLnhEaWZmO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgLSBtb3ZlSW5mby55RGlmZjtcbiAgICB9LFxuICAgIHNldFVwcGVyTGVmdCh1cHBlckxlZnQpIHtcbiAgICAgICAgaWYgKHVwcGVyTGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cHBlckxlZnQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSB1cHBlckxlZnQueDtcbiAgICAgICAgdGhpcy55ID0gdXBwZXJMZWZ0Lnk7XG4gICAgfSxcbn0pO1xuXG5kZWZpbmVTaGFwZShcIlJlY3RhbmdsZVwiLCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gYXJncy54IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IGFyZ3MueSB8fCAwO1xuICAgICAgICB0aGlzLndpZHRoID0gYXJncy53aWR0aCB8fCAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGFyZ3MuaGVpZ2h0IHx8IDA7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBhcmdzLnN0cm9rZVdpZHRoIHx8IDE7XG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBhcmdzLnN0cm9rZUNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBhcmdzLmZpbGxDb2xvciB8fCBcInRyYW5zcGFyZW50XCI7XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMueCAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgICAgeTogdGhpcy55IC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHRoaXMuZmlsbENvbG9yLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoXCJSZWN0YW5nbGVcIiwgZGF0YSk7XG4gICAgfSxcbiAgICBtb3ZlKG1vdmVJbmZvKSB7XG4gICAgICAgIGlmIChtb3ZlSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3ZlSW5mbyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCAtIG1vdmVJbmZvLnhEaWZmO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgLSBtb3ZlSW5mby55RGlmZjtcbiAgICB9LFxuICAgIHNldFVwcGVyTGVmdCh1cHBlckxlZnQpIHtcbiAgICAgICAgaWYgKHVwcGVyTGVmdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cHBlckxlZnQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSB1cHBlckxlZnQueDtcbiAgICAgICAgdGhpcy55ID0gdXBwZXJMZWZ0Lnk7XG4gICAgfSxcbn0pO1xuXG4vLyB0aGlzIGlzIHByZXR0eSBzaW1pbGFyIHRvIHRoZSBSZWN0YW5nbGUgc2hhcGUuIG1heWJlIGNvbnNvbGlkYXRlIHNvbWVob3cuXG5kZWZpbmVTaGFwZShcIkVsbGlwc2VcIiwge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IGFyZ3MueCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSBhcmdzLnkgfHwgMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IGFyZ3Mud2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBhcmdzLmhlaWdodCB8fCAwO1xuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gYXJncy5zdHJva2VXaWR0aCB8fCAxO1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gYXJncy5zdHJva2VDb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gYXJncy5maWxsQ29sb3IgfHwgXCJ0cmFuc3BhcmVudFwiO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLnggLSB0aGlzLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMueSAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiB0aGlzLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiB0aGlzLmZpbGxDb2xvcixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYXBlKFwiRWxsaXBzZVwiLCBkYXRhKTtcbiAgICB9LFxuICAgIG1vdmUobW92ZUluZm8pIHtcbiAgICAgICAgaWYgKG1vdmVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVJbmZvID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gdGhpcy54IC0gbW92ZUluZm8ueERpZmY7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSAtIG1vdmVJbmZvLnlEaWZmO1xuICAgIH0sXG4gICAgc2V0VXBwZXJMZWZ0KHVwcGVyTGVmdCkge1xuICAgICAgICBpZiAodXBwZXJMZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHVwcGVyTGVmdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IHVwcGVyTGVmdC54O1xuICAgICAgICB0aGlzLnkgPSB1cHBlckxlZnQueTtcbiAgICB9LFxufSk7XG5cbmRlZmluZVNoYXBlKFwiTGluZVwiLCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54MSA9IGFyZ3MueDEgfHwgMDtcbiAgICAgICAgdGhpcy55MSA9IGFyZ3MueTEgfHwgMDtcbiAgICAgICAgdGhpcy54MiA9IGFyZ3MueDIgfHwgMDtcbiAgICAgICAgdGhpcy55MiA9IGFyZ3MueTIgfHwgMDtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IGFyZ3Muc3Ryb2tlV2lkdGggfHwgMTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGFyZ3MuY29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICB0aGlzLmNhcFN0eWxlID0gYXJncy5jYXBTdHlsZSB8fCBcInJvdW5kXCI7XG4gICAgICAgIHRoaXMuZW5kQ2FwU2hhcGVzID0gYXJncy5lbmRDYXBTaGFwZXMgfHwgW251bGwsIG51bGxdO1xuICAgICAgICB0aGlzLmRhc2ggPSBhcmdzLmRhc2ggfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogTWF0aC5taW4odGhpcy54MSwgdGhpcy54MikgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpICsgdGhpcy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKSArIHRoaXMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IHRoaXMueDEsXG4gICAgICAgICAgICB5MTogdGhpcy55MSxcbiAgICAgICAgICAgIHgyOiB0aGlzLngyLFxuICAgICAgICAgICAgeTI6IHRoaXMueTIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgY2FwU3R5bGU6IHRoaXMuY2FwU3R5bGUsXG4gICAgICAgICAgICBkYXNoOiB0aGlzLmRhc2gsXG4gICAgICAgICAgICBlbmRDYXBTaGFwZXM6IHRoaXMuZW5kQ2FwU2hhcGVzLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoXCJMaW5lXCIsIGRhdGEpO1xuICAgIH0sXG4gICAgbW92ZShtb3ZlSW5mbykge1xuICAgICAgICBpZiAobW92ZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbW92ZUluZm8gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLngxID0gdGhpcy54MSAtIG1vdmVJbmZvLnhEaWZmO1xuICAgICAgICB0aGlzLnkxID0gdGhpcy55MSAtIG1vdmVJbmZvLnlEaWZmO1xuICAgICAgICB0aGlzLngyID0gdGhpcy54MiAtIG1vdmVJbmZvLnhEaWZmO1xuICAgICAgICB0aGlzLnkyID0gdGhpcy55MiAtIG1vdmVJbmZvLnlEaWZmO1xuICAgIH0sXG4gICAgc2V0VXBwZXJMZWZ0KHVwcGVyTGVmdCkge1xuICAgICAgICBpZiAodXBwZXJMZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHVwcGVyTGVmdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBici54IC0gdXBwZXJMZWZ0Lng7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gYnIueSAtIHVwcGVyTGVmdC55O1xuICAgICAgICB0aGlzLm1vdmUoe3hEaWZmLCB5RGlmZn0pO1xuICAgIH0sXG59KTtcblxuLy8gcmV0dXJucyBmYWxzZSBpZiBubyBwb2ludHMgYmVjYXVzZSB0aGVyZSBhcmUgbm8gcG9pbnRzIHRvIHNoYXJlIHN0eWxlXG5jb25zdCBfZG9BbGxQb2ludHNTaGFyZVN0eWxlID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge3NpemV9ID0gcG9pbnRzWzBdO1xuICAgIGNvbnN0IHtjb2xvcn0gPSBwb2ludHNbMF07XG4gICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgIGlmIChwb2ludC5zaXplICE9PSBzaXplIHx8IHBvaW50LmNvbG9yICE9PSBjb2xvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coc2l6ZSwgY29sb3IsIHBvaW50LnNpemUsIHBvaW50LmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQuc2l6ZSAhPT0gc2l6ZSB8fCBwb2ludC5jb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IF9jcmVhdGVMaW5lUGF0aEZyb21EYXRhID0gZnVuY3Rpb24oc2hhcGVOYW1lLCBkYXRhKSB7XG4gICAgbGV0IHgsIHk7XG4gICAgbGV0IHBvaW50cyA9IG51bGw7XG4gICAgaWYgKGRhdGEucG9pbnRzKSB7XG4gICAgICAgIHBvaW50cyA9IGRhdGEucG9pbnRzLm1hcChwb2ludERhdGEgPT4gSlNPTlRvU2hhcGUocG9pbnREYXRhKSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnBvaW50Q29vcmRpbmF0ZVBhaXJzKSB7XG4gICAgICAgIHBvaW50cyA9IGRhdGEucG9pbnRDb29yZGluYXRlUGFpcnMubWFwKChbeCwgeV0pID0+XG4gICAgICAgICAgICBKU09OVG9TaGFwZSh7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlBvaW50XCIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhLnBvaW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGRhdGEucG9pbnRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBkYXRhLnNtb290aCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHNtb290aGVkUG9pbnRzID0gbnVsbDtcbiAgICBpZiAoZGF0YS5zbW9vdGhlZFBvaW50Q29vcmRpbmF0ZVBhaXJzKSB7XG4gICAgICAgIHNtb290aGVkUG9pbnRzID0gZGF0YS5zbW9vdGhlZFBvaW50Q29vcmRpbmF0ZVBhaXJzLm1hcCgoW3gsIHldKSA9PlxuICAgICAgICAgICAgSlNPTlRvU2hhcGUoe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZGF0YS5wb2ludFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkYXRhLnBvaW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNtb290aDogZGF0YS5zbW9vdGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghcG9pbnRzWzBdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlU2hhcGUoc2hhcGVOYW1lLCB7XG4gICAgICAgIHBvaW50cyxcbiAgICAgICAgc21vb3RoZWRQb2ludHMsXG4gICAgICAgIG9yZGVyOiBkYXRhLm9yZGVyLFxuICAgICAgICB0YWlsU2l6ZTogZGF0YS50YWlsU2l6ZSxcbiAgICAgICAgc21vb3RoOiBkYXRhLnNtb290aCxcbiAgICB9KTtcbn07XG5cbmNvbnN0IGxpbmVQYXRoRnVuY3MgPSB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRzID0gYXJncy5wb2ludHMgfHwgW107XG4gICAgICAgIHRoaXMub3JkZXIgPSBhcmdzLm9yZGVyIHx8IDM7XG4gICAgICAgIHRoaXMudGFpbFNpemUgPSBhcmdzLnRhaWxTaXplIHx8IDM7XG4gICAgICAgIHRoaXMuc21vb3RoID0gXCJzbW9vdGhcIiBpbiBhcmdzID8gYXJncy5zbW9vdGggOiB0cnVlO1xuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc21vb3RoZWQgcG9pbnRzIGdlbmVyYXRlZCBmb3IgZWFjaCBwb2ludCBhZGRlZFxuICAgICAgICB0aGlzLnNlZ21lbnRTaXplID0gTWF0aC5wb3coMiwgdGhpcy5vcmRlcik7XG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBwb2ludHMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJzcGxpbmUgdG8gdGhlIG5ld2VzdCBwb2ludFxuICAgICAgICB0aGlzLnNhbXBsZVNpemUgPSB0aGlzLnRhaWxTaXplICsgMTtcblxuICAgICAgICBpZiAoYXJncy5zbW9vdGhlZFBvaW50cykge1xuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBhcmdzLnBvaW50cztcbiAgICAgICAgICAgIHRoaXMuc21vb3RoZWRQb2ludHMgPSBhcmdzLnNtb290aGVkUG9pbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHBvaW50cy5tYXAocG9pbnQgPT4gdGhpcy5hZGRQb2ludChwb2ludCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLm1hcChwID0+ICh7XG4gICAgICAgICAgICAgICAgeDogcC54IC0gcC5zaXplIC8gMixcbiAgICAgICAgICAgICAgICB5OiBwLnkgLSBwLnNpemUgLyAyLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBwLnNpemUsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwLnNpemUsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKF9kb0FsbFBvaW50c1NoYXJlU3R5bGUodGhpcy5wb2ludHMpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgIHRhaWxTaXplOiB0aGlzLnRhaWxTaXplLFxuICAgICAgICAgICAgICAgIHNtb290aDogdGhpcy5zbW9vdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRDb29yZGluYXRlUGFpcnM6IHRoaXMucG9pbnRzLm1hcChwb2ludCA9PiBbXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgc21vb3RoZWRQb2ludENvb3JkaW5hdGVQYWlyczogdGhpcy5zbW9vdGhlZFBvaW50cy5tYXAocG9pbnQgPT4gW1xuICAgICAgICAgICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICBwb2ludC55LFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHBvaW50U2l6ZTogdGhpcy5wb2ludHNbMF0uc2l6ZSxcbiAgICAgICAgICAgICAgICBwb2ludENvbG9yOiB0aGlzLnBvaW50c1swXS5jb2xvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgIHRhaWxTaXplOiB0aGlzLnRhaWxTaXplLFxuICAgICAgICAgICAgICAgIHNtb290aDogdGhpcy5zbW9vdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cy5tYXAocCA9PiBzaGFwZVRvSlNPTihwKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVMaW5lUGF0aEZyb21EYXRhKFwiTGluZVBhdGhcIiwgZGF0YSk7XG4gICAgfSxcblxuICAgIGFkZFBvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5zbW9vdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoZWRQb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zbW9vdGhlZFBvaW50cyB8fCB0aGlzLnBvaW50cy5sZW5ndGggPCB0aGlzLnNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoZWRQb2ludHMgPSBic3BsaW5lKHRoaXMucG9pbnRzLCB0aGlzLm9yZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGxhc3QoXG4gICAgICAgICAgICAgICAgYnNwbGluZShsYXN0KHRoaXMucG9pbnRzLCB0aGlzLnNhbXBsZVNpemUpLCB0aGlzLm9yZGVyKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRTaXplICogdGhpcy50YWlsU2l6ZSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBAdGFpbFNpemUgLSAxIHNlZ21lbnRzIGZyb20gQHNtb290aGVkUG9pbnRzXG4gICAgICAgICAgICAvLyB0aGVuIGNvbmNhdCB0aGUgdGFpbC4gVGhpcyBpcyBkb25lIGJlY2F1c2Ugc21vb3RoZWQgcG9pbnRzXG4gICAgICAgICAgICAvLyBjbG9zZSB0byB0aGUgZW5kIG9mIHRoZSBwYXRoIHdpbGwgY2hhbmdlIGFzIG5ldyBwb2ludHMgYXJlXG4gICAgICAgICAgICAvLyBhZGRlZC5cbiAgICAgICAgICAgIHRoaXMuc21vb3RoZWRQb2ludHMgPSB0aGlzLnNtb290aGVkUG9pbnRzXG4gICAgICAgICAgICAgICAgLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNtb290aGVkUG9pbnRzLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZ21lbnRTaXplICogKHRoaXMudGFpbFNpemUgLSAxKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLnRhaWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdmUobW92ZUluZm8pIHtcbiAgICAgICAgbGV0IHB0cztcbiAgICAgICAgaWYgKG1vdmVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVJbmZvID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNtb290aCkge1xuICAgICAgICAgICAgcHRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdHMgPSB0aGlzLnNtb290aGVkUG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcHQgb2YgcHRzKSB7XG4gICAgICAgICAgICBwdC5tb3ZlKG1vdmVJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5zbW9vdGhlZFBvaW50cztcbiAgICB9LFxuXG4gICAgc2V0VXBwZXJMZWZ0KHVwcGVyTGVmdCkge1xuICAgICAgICBpZiAodXBwZXJMZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHVwcGVyTGVmdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBici54IC0gdXBwZXJMZWZ0Lng7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gYnIueSAtIHVwcGVyTGVmdC55O1xuICAgICAgICB0aGlzLm1vdmUoe3hEaWZmLCB5RGlmZn0pO1xuICAgIH0sXG59O1xuXG5jb25zdCBMaW5lUGF0aCA9IGRlZmluZVNoYXBlKFwiTGluZVBhdGhcIiwgbGluZVBhdGhGdW5jcyk7XG5cbmRlZmluZVNoYXBlKFwiRXJhc2VkTGluZVBhdGhcIiwge1xuICAgIGNvbnN0cnVjdG9yOiBsaW5lUGF0aEZ1bmNzLmNvbnN0cnVjdG9yLFxuICAgIHRvSlNPTjogbGluZVBhdGhGdW5jcy50b0pTT04sXG4gICAgYWRkUG9pbnQ6IGxpbmVQYXRoRnVuY3MuYWRkUG9pbnQsXG4gICAgZ2V0Qm91bmRpbmdSZWN0OiBsaW5lUGF0aEZ1bmNzLmdldEJvdW5kaW5nUmVjdCxcblxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVMaW5lUGF0aEZyb21EYXRhKFwiRXJhc2VkTGluZVBhdGhcIiwgZGF0YSk7XG4gICAgfSxcbn0pO1xuXG4vLyB0aGlzIGlzIGN1cnJlbnRseSBqdXN0IHVzZWQgZm9yIExpbmVQYXRoL0VyYXNlZExpbmVQYXRoIGludGVybmFsIHN0b3JhZ2UuXG5kZWZpbmVTaGFwZShcIlBvaW50XCIsIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSBhcmdzLnggfHwgMDtcbiAgICAgICAgdGhpcy55ID0gYXJncy55IHx8IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGFyZ3Muc2l6ZSB8fCAwO1xuICAgICAgICB0aGlzLmNvbG9yID0gYXJncy5jb2xvciB8fCBcIlwiO1xuICAgIH0sXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy54IC0gdGhpcy5zaXplIC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMueSAtIHRoaXMuc2l6ZSAvIDIsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5zaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7eDogdGhpcy54LCB5OiB0aGlzLnksIHNpemU6IHRoaXMuc2l6ZSwgY29sb3I6IHRoaXMuY29sb3J9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoXCJQb2ludFwiLCBkYXRhKTtcbiAgICB9LFxuICAgIG1vdmUobW92ZUluZm8pIHtcbiAgICAgICAgaWYgKG1vdmVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVJbmZvID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gdGhpcy54IC0gbW92ZUluZm8ueERpZmY7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueSAtIG1vdmVJbmZvLnlEaWZmO1xuICAgIH0sXG4gICAgc2V0VXBwZXJMZWZ0KHVwcGVyTGVmdCkge1xuICAgICAgICBpZiAodXBwZXJMZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHVwcGVyTGVmdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueCA9IHVwcGVyTGVmdC54O1xuICAgICAgICB0aGlzLnkgPSB1cHBlckxlZnQueTtcbiAgICB9LFxufSk7XG5cbmRlZmluZVNoYXBlKFwiUG9seWdvblwiLCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHMgPSBhcmdzLnBvaW50cztcbiAgICAgICAgdGhpcy5maWxsQ29sb3IgPSBhcmdzLmZpbGxDb2xvciB8fCBcIndoaXRlXCI7XG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBhcmdzLnN0cm9rZUNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IGFyZ3Muc3Ryb2tlV2lkdGg7XG4gICAgICAgIHRoaXMuZGFzaCA9IGFyZ3MuZGFzaCB8fCBudWxsO1xuXG4gICAgICAgIGlmIChhcmdzLmlzQ2xvc2VkID09IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3MuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBhcmdzLmlzQ2xvc2VkO1xuXG4gICAgICAgIC8vIGlnbm9yZSBwb2ludCB2YWx1ZXNcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICBwb2ludC5jb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICBwb2ludC5zaXplID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZFBvaW50KHgsIHkpIHtcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaChjcmVhdGVTaGFwZShcIlBvaW50XCIsIHt4LCB5fSkpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoKSB7XG4gICAgICAgIHJldHVybiBnZXRCb3VuZGluZ1JlY3QodGhpcy5wb2ludHMubWFwKHAgPT4gcC5nZXRCb3VuZGluZ1JlY3QoKSkpO1xuICAgIH0sXG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIGRhc2g6IHRoaXMuZGFzaCxcbiAgICAgICAgICAgIGlzQ2xvc2VkOiB0aGlzLmlzQ2xvc2VkLFxuICAgICAgICAgICAgcG9pbnRDb29yZGluYXRlUGFpcnM6IHRoaXMucG9pbnRzLm1hcChwID0+IFtwLngsIHAueV0pLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICBkYXRhLnBvaW50cyA9IGRhdGEucG9pbnRDb29yZGluYXRlUGFpcnMubWFwKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGFyZ3NbMF07XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoXCJQb2ludFwiLCB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHNpemU6IGRhdGEuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGRhdGEuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFwZShcIlBvbHlnb25cIiwgZGF0YSk7XG4gICAgfSxcblxuICAgIG1vdmUobW92ZUluZm8pIHtcbiAgICAgICAgaWYgKG1vdmVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdmVJbmZvID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHMubWFwKHB0ID0+IHB0Lm1vdmUobW92ZUluZm8pKTtcbiAgICB9LFxuXG4gICAgc2V0VXBwZXJMZWZ0KHVwcGVyTGVmdCkge1xuICAgICAgICBpZiAodXBwZXJMZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHVwcGVyTGVmdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBici54IC0gdXBwZXJMZWZ0Lng7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gYnIueSAtIHVwcGVyTGVmdC55O1xuICAgICAgICB0aGlzLm1vdmUoe3hEaWZmLCB5RGlmZn0pO1xuICAgIH0sXG59KTtcblxuZGVmaW5lU2hhcGUoXCJUZXh0XCIsIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSBhcmdzLnggfHwgMDtcbiAgICAgICAgdGhpcy55ID0gYXJncy55IHx8IDA7XG4gICAgICAgIHRoaXMudiA9IGFyZ3MudiB8fCAwOyAvLyB2ZXJzaW9uICg8MSBuZWVkcyBwb3NpdGlvbiByZXBhaXJlZClcbiAgICAgICAgdGhpcy50ZXh0ID0gYXJncy50ZXh0IHx8IFwiXCI7XG4gICAgICAgIHRoaXMuY29sb3IgPSBhcmdzLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgdGhpcy5mb250ID0gYXJncy5mb250IHx8IFwiMThweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgIHRoaXMuZm9yY2VkV2lkdGggPSBhcmdzLmZvcmNlZFdpZHRoIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkSGVpZ2h0ID0gYXJncy5mb3JjZWRIZWlnaHQgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgX21ha2VSZW5kZXJlcihjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVIZWlnaHQgPSAxLjI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyKFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgdGhpcy50ZXh0LFxuICAgICAgICAgICAgdGhpcy5mb250LFxuICAgICAgICAgICAgdGhpcy5mb3JjZWRXaWR0aCxcbiAgICAgICAgICAgIHRoaXMuZm9yY2VkSGVpZ2h0LFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLnYgPCAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlcGFpcmluZyBiYXNlbGluZVwiKTtcbiAgICAgICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgICAgICB0aGlzLnggLT0gdGhpcy5yZW5kZXJlci5tZXRyaWNzLmJvdW5kcy5taW54O1xuICAgICAgICAgICAgdGhpcy55IC09XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5tZXRyaWNzLmxlYWRpbmcgLSB0aGlzLnJlbmRlcmVyLm1ldHJpY3MuZGVzY2VudDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRUZXh0KHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgfSxcblxuICAgIHNldEZvbnQoZm9udCkge1xuICAgICAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgc2V0UG9zaXRpb24oeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH0sXG5cbiAgICBzZXRTaXplKGZvcmNlZFdpZHRoLCBmb3JjZWRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5mb3JjZWRXaWR0aCA9IE1hdGgubWF4KGZvcmNlZFdpZHRoLCAwKTtcbiAgICAgICAgdGhpcy5mb3JjZWRIZWlnaHQgPSBNYXRoLm1heChmb3JjZWRIZWlnaHQsIDApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgZW5mb3JjZU1heEJvdW5kaW5nUmVjdChsYykge1xuICAgICAgICBjb25zdCBiciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGxjLmN0eCk7XG4gICAgICAgIGNvbnN0IGxjQm91bmRpbmdSZWN0ID0ge1xuICAgICAgICAgICAgeDogLWxjLnBvc2l0aW9uLnggLyBsYy5zY2FsZSxcbiAgICAgICAgICAgIHk6IC1sYy5wb3NpdGlvbi55IC8gbGMuc2NhbGUsXG4gICAgICAgICAgICB3aWR0aDogbGMuY2FudmFzLndpZHRoIC8gbGMuc2NhbGUsXG4gICAgICAgICAgICBoZWlnaHQ6IGxjLmNhbnZhcy5oZWlnaHQgLyBsYy5zY2FsZSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVhbGx5IGp1c3QgZW5mb3JjZSBtYXggd2lkdGhcbiAgICAgICAgaWYgKGJyLnggKyBici53aWR0aCA+IGxjQm91bmRpbmdSZWN0LnggKyBsY0JvdW5kaW5nUmVjdC53aWR0aCkge1xuICAgICAgICAgICAgY29uc3QgZHggPSBici54IC0gbGNCb3VuZGluZ1JlY3QueDtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VkV2lkdGggPSBsY0JvdW5kaW5nUmVjdC53aWR0aCAtIGR4IC0gMTA7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ1JlY3QoY3R4LCBpc0VkaXRpbmcpIHtcbiAgICAgICAgLy8gaWYgaXNFZGl0aW5nID09IHRydWUsIGFkZCBYIHBhZGRpbmcgdG8gYWNjb3VudCBmb3IgY2FyYXRcbiAgICAgICAgaWYgKGlzRWRpdGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlUmVuZGVyZXIoY3R4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJNdXN0IHBhc3MgY3R4IGlmIHRleHQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IodGhpcy54KSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IodGhpcy55KSxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwodGhpcy5yZW5kZXJlci5nZXRXaWR0aCh0cnVlKSksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbCh0aGlzLnJlbmRlcmVyLmdldEhlaWdodCgpKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgICAgICAgZm9yY2VkV2lkdGg6IHRoaXMuZm9yY2VkV2lkdGgsXG4gICAgICAgICAgICBmb3JjZWRIZWlnaHQ6IHRoaXMuZm9yY2VkSGVpZ2h0LFxuICAgICAgICAgICAgdjogdGhpcy52LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2hhcGUoXCJUZXh0XCIsIGRhdGEpO1xuICAgIH0sXG4gICAgbW92ZShtb3ZlSW5mbykge1xuICAgICAgICBpZiAobW92ZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbW92ZUluZm8gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSB0aGlzLnggLSBtb3ZlSW5mby54RGlmZjtcbiAgICAgICAgdGhpcy55ID0gdGhpcy55IC0gbW92ZUluZm8ueURpZmY7XG4gICAgfSxcbiAgICBzZXRVcHBlckxlZnQodXBwZXJMZWZ0KSB7XG4gICAgICAgIGlmICh1cHBlckxlZnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBwZXJMZWZ0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gdXBwZXJMZWZ0Lng7XG4gICAgICAgIHRoaXMueSA9IHVwcGVyTGVmdC55O1xuICAgIH0sXG59KTtcblxuZGVmaW5lU2hhcGUoXCJTZWxlY3Rpb25Cb3hcIiwge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUgPSBhcmdzLnNoYXBlO1xuICAgICAgICBpZiAoYXJncy5oYW5kbGVTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6ZSA9IGFyZ3MuaGFuZGxlU2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6ZSA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyZ2luID0gNDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBhcmdzLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgICAgICB0aGlzLl9iciA9IHRoaXMuc2hhcGUuZ2V0Qm91bmRpbmdSZWN0KGFyZ3MuY3R4KTtcbiAgICB9LFxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhcGU6IHNoYXBlVG9KU09OKHRoaXMuc2hhcGUpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKHtzaGFwZSwgaGFuZGxlU2l6ZSwgbWFyZ2luLCBiYWNrZ3JvdW5kQ29sb3J9KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFwZShcIlNlbGVjdGlvbkJveFwiLCB7XG4gICAgICAgICAgICBzaGFwZTogSlNPTlRvU2hhcGUoc2hhcGUpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VG9wTGVmdEhhbmRsZVJlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9ici54IC0gdGhpcy5oYW5kbGVTaXplIC0gdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICB5OiB0aGlzLl9ici55IC0gdGhpcy5oYW5kbGVTaXplIC0gdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5oYW5kbGVTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhhbmRsZVNpemUsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEJvdHRvbUxlZnRIYW5kbGVSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy5fYnIueCAtIHRoaXMuaGFuZGxlU2l6ZSAtIHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgeTogdGhpcy5fYnIueSArIHRoaXMuX2JyLmhlaWdodCArIHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuaGFuZGxlU2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oYW5kbGVTaXplLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRUb3BSaWdodEhhbmRsZVJlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9ici54ICsgdGhpcy5fYnIud2lkdGggKyB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHk6IHRoaXMuX2JyLnkgLSB0aGlzLmhhbmRsZVNpemUgLSB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmhhbmRsZVNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGFuZGxlU2l6ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Qm90dG9tUmlnaHRIYW5kbGVSZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy5fYnIueCArIHRoaXMuX2JyLndpZHRoICsgdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICB5OiB0aGlzLl9ici55ICsgdGhpcy5fYnIuaGVpZ2h0ICsgdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5oYW5kbGVTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhhbmRsZVNpemUsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nUmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHRoaXMuX2JyLnggLSB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHk6IHRoaXMuX2JyLnkgLSB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9ici53aWR0aCArIHRoaXMubWFyZ2luICogMixcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5fYnIuaGVpZ2h0ICsgdGhpcy5tYXJnaW4gKiAyLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHtkZWZpbmVTaGFwZSwgY3JlYXRlU2hhcGUsIEpTT05Ub1NoYXBlLCBzaGFwZVRvSlNPTn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/shapes.js\n',
                );

                /***/
            },

        /***/ "./src/svgRenderer.js":
            /*!****************************!*\
  !*** ./src/svgRenderer.js ***!
  \****************************/
            /*! exports provided: defineSVGRenderer, renderShapeToSVG */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    "__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineSVGRenderer\", function() { return defineSVGRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderShapeToSVG\", function() { return renderShapeToSVG; });\n/* harmony import */ var _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lineEndCapShapes */ \"./src/lineEndCapShapes.js\");\n\n\nconst renderers = {};\n\n// shapeToSVG(shape) -> string\nconst defineSVGRenderer = (shapeName, shapeToSVGFunc) =>\n    (renderers[shapeName] = shapeToSVGFunc);\n\nconst renderShapeToSVG = function(shape, opts) {\n    if (opts == null) {\n        opts = {};\n    }\n    if (opts.shouldIgnoreUnsupportedShapes == null) {\n        opts.shouldIgnoreUnsupportedShapes = false;\n    }\n\n    if (renderers[shape.className]) {\n        return renderers[shape.className](shape);\n    } else if (opts.shouldIgnoreUnsupportedShapes) {\n        console.warn(`Can't render shape of type ${shape.className} to SVG`);\n        return \"\";\n    } else {\n        throw `Can't render shape of type ${shape.className} to SVG`;\n    }\n};\n\nconst entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#x60;\",\n    \"=\": \"&#x3D;\",\n};\n\nconst escapeHTML = string =>\n    String(string).replace(/[&<>\"'`=/]/g, s => entityMap[s]);\n\ndefineSVGRenderer(\"Rectangle\", function(shape) {\n    const x1 = shape.x;\n    const y1 = shape.y;\n    const x2 = shape.x + shape.width;\n    const y2 = shape.y + shape.height;\n\n    let x = Math.min(x1, x2);\n    let y = Math.min(y1, y2);\n    const width = Math.max(x1, x2) - x;\n    const height = Math.max(y1, y2) - y;\n\n    if (shape.strokeWidth % 2 !== 0) {\n        x += 0.5;\n        y += 0.5;\n    }\n\n    return `\\\n<rect x='${x}' y='${y}' \\\nwidth='${width}' height='${height}' \\\nstroke='${shape.strokeColor}' fill='${shape.fillColor}' \\\nstroke-width='${shape.strokeWidth}' />\\\n`;\n});\n\ndefineSVGRenderer(\"SelectionBox\", () => {});\n\ndefineSVGRenderer(\"Ellipse\", function(shape) {\n    const halfWidth = Math.floor(shape.width / 2);\n    const halfHeight = Math.floor(shape.height / 2);\n    const centerX = shape.x + halfWidth;\n    const centerY = shape.y + halfHeight;\n    return `\\\n<ellipse cx='${centerX}' cy='${centerY}' rx='${Math.abs(halfWidth)}' \\\nry='${Math.abs(halfHeight)}' \\\nstroke='${shape.strokeColor}' fill='${shape.fillColor}' \\\nstroke-width='${shape.strokeWidth}' />\\\n`;\n});\n\ndefineSVGRenderer(\n    \"Image\",\n    shape =>\n        // This will only work when embedded in a web page.\n        `\\\n<image x='${shape.x}' y='${shape.y}' \\\nwidth='${shape.image.naturalWidth * shape.scale}' \\\nheight='${shape.image.naturalHeight * shape.scale}' \\\nxlink:href='${shape.image.src}' />\\\n`,\n);\n\ndefineSVGRenderer(\"Line\", function(shape) {\n    const dashString = shape.dash\n        ? `stroke-dasharray='${shape.dash.join(\", \")}'`\n        : \"\";\n    let capString = \"\";\n    const arrowWidth = Math.max(shape.strokeWidth * 2.2, 5);\n\n    let {x1} = shape;\n    let {x2} = shape;\n    let {y1} = shape;\n    let {y2} = shape;\n    if (shape.strokeWidth % 2 !== 0) {\n        x1 += 0.5;\n        x2 += 0.5;\n        y1 += 0.5;\n        y2 += 0.5;\n    }\n\n    if (shape.endCapShapes[0]) {\n        capString += _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__[\"default\"][shape.endCapShapes[0]].svg(\n            x1,\n            y1,\n            Math.atan2(y1 - y2, x1 - x2),\n            arrowWidth,\n            shape.color,\n        );\n    }\n    if (shape.endCapShapes[1]) {\n        capString += _lineEndCapShapes__WEBPACK_IMPORTED_MODULE_0__[\"default\"][shape.endCapShapes[1]].svg(\n            x2,\n            y2,\n            Math.atan2(y2 - y1, x2 - x1),\n            arrowWidth,\n            shape.color,\n        );\n    }\n    return `\\\n<g> \\\n<line x1='${x1}' y1='${y1}' x2='${x2}' y2='${y2}' \\\n${dashString} \\\nstroke-linecap='${shape.capStyle}' \\\nstroke='${shape.color}' stroke-width='${shape.strokeWidth}' /> \\\n${capString} \\\n</g>\\\n`;\n});\n\ndefineSVGRenderer(\n    \"LinePath\",\n    shape =>\n        `\\\n<polyline \\\nfill='none' \\\npoints='${shape.smoothedPoints\n            .map(function(p) {\n                const offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n                return `${p.x + offset},${p.y + offset}`;\n            })\n            .join(\" \")}' \\\nstroke='${shape.points[0].color}' \\\nstroke-linecap='round' \\\nstroke-width='${shape.points[0].size}' />\\\n`,\n);\n\n// silently skip erasers\ndefineSVGRenderer(\"ErasedLinePath\", () => {});\n\ndefineSVGRenderer(\"Polygon\", function(shape) {\n    if (shape.isClosed) {\n        return `\\\n<polygon \\\nfill='${shape.fillColor}' \\\npoints='${shape.points\n            .map(function(p) {\n                const offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n                return `${p.x + offset},${p.y + offset}`;\n            })\n            .join(\" \")}' \\\nstroke='${shape.strokeColor}' \\\nstroke-width='${shape.strokeWidth}' />\\\n`;\n    } else {\n        return `\\\n<polyline \\\nfill='${shape.fillColor}' \\\npoints='${shape.points\n            .map(function(p) {\n                const offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n                return `${p.x + offset},${p.y + offset}`;\n            })\n            .join(\" \")}' \\\nstroke='none' /> \\\n<polyline \\\nfill='none' \\\npoints='${shape.points\n            .map(function(p) {\n                const offset = p.strokeWidth % 2 === 0 ? 0.0 : 0.5;\n                return `${p.x + offset},${p.y + offset}`;\n            })\n            .join(\" \")}' \\\nstroke='${shape.strokeColor}' \\\nstroke-width='${shape.strokeWidth}' />\\\n`;\n    }\n});\n\ndefineSVGRenderer(\"Text\", function(shape) {\n    // fallback: don't worry about auto-wrapping\n    const widthString = shape.forcedWidth\n        ? `width='${shape.forcedWidth}px'`\n        : \"\";\n    const heightString = shape.forcedHeight\n        ? `height='${shape.forcedHeight}px'`\n        : \"\";\n    let textSplitOnLines = shape.text.split(/\\r\\n|\\r|\\n/g);\n\n    if (shape.renderer) {\n        textSplitOnLines = shape.renderer.lines;\n    }\n\n    return `\\\n<text x='${shape.x}' y='${shape.y}' \\\n${widthString} ${heightString} \\\nfill='${shape.color}' \\\nstyle='font: ${shape.font};'> \\\n${textSplitOnLines\n        .map((line, i) => {\n            const dy = i === 0 ? 0 : \"1.2em\";\n            return `\\\n<tspan x='${shape.x}' dy='${dy}' alignment-baseline='text-before-edge'> \\\n${escapeHTML(line)} \\\n</tspan>`;\n        })\n        .join(\"\")} \\\n</text>\\\n`;\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3ZnUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3ZnUmVuZGVyZXIuanM/MWNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbGluZUVuZENhcFNoYXBlcyBmcm9tIFwiLi9saW5lRW5kQ2FwU2hhcGVzXCI7XG5cbmNvbnN0IHJlbmRlcmVycyA9IHt9O1xuXG4vLyBzaGFwZVRvU1ZHKHNoYXBlKSAtPiBzdHJpbmdcbmNvbnN0IGRlZmluZVNWR1JlbmRlcmVyID0gKHNoYXBlTmFtZSwgc2hhcGVUb1NWR0Z1bmMpID0+XG4gICAgKHJlbmRlcmVyc1tzaGFwZU5hbWVdID0gc2hhcGVUb1NWR0Z1bmMpO1xuXG5jb25zdCByZW5kZXJTaGFwZVRvU1ZHID0gZnVuY3Rpb24oc2hhcGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2hvdWxkSWdub3JlVW5zdXBwb3J0ZWRTaGFwZXMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzLnNob3VsZElnbm9yZVVuc3VwcG9ydGVkU2hhcGVzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlcmVyc1tzaGFwZS5jbGFzc05hbWVdKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlcnNbc2hhcGUuY2xhc3NOYW1lXShzaGFwZSk7XG4gICAgfSBlbHNlIGlmIChvcHRzLnNob3VsZElnbm9yZVVuc3VwcG9ydGVkU2hhcGVzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ2FuJ3QgcmVuZGVyIHNoYXBlIG9mIHR5cGUgJHtzaGFwZS5jbGFzc05hbWV9IHRvIFNWR2ApO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgQ2FuJ3QgcmVuZGVyIHNoYXBlIG9mIHR5cGUgJHtzaGFwZS5jbGFzc05hbWV9IHRvIFNWR2A7XG4gICAgfVxufTtcblxuY29uc3QgZW50aXR5TWFwID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAnXCInOiBcIiZxdW90O1wiLFxuICAgIFwiJ1wiOiBcIiYjMzk7XCIsXG4gICAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gICAgXCJgXCI6IFwiJiN4NjA7XCIsXG4gICAgXCI9XCI6IFwiJiN4M0Q7XCIsXG59O1xuXG5jb25zdCBlc2NhcGVIVE1MID0gc3RyaW5nID0+XG4gICAgU3RyaW5nKHN0cmluZykucmVwbGFjZSgvWyY8PlwiJ2A9L10vZywgcyA9PiBlbnRpdHlNYXBbc10pO1xuXG5kZWZpbmVTVkdSZW5kZXJlcihcIlJlY3RhbmdsZVwiLCBmdW5jdGlvbihzaGFwZSkge1xuICAgIGNvbnN0IHgxID0gc2hhcGUueDtcbiAgICBjb25zdCB5MSA9IHNoYXBlLnk7XG4gICAgY29uc3QgeDIgPSBzaGFwZS54ICsgc2hhcGUud2lkdGg7XG4gICAgY29uc3QgeTIgPSBzaGFwZS55ICsgc2hhcGUuaGVpZ2h0O1xuXG4gICAgbGV0IHggPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgIGxldCB5ID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KHgxLCB4MikgLSB4O1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHkxLCB5MikgLSB5O1xuXG4gICAgaWYgKHNoYXBlLnN0cm9rZVdpZHRoICUgMiAhPT0gMCkge1xuICAgICAgICB4ICs9IDAuNTtcbiAgICAgICAgeSArPSAwLjU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcXFxuPHJlY3QgeD0nJHt4fScgeT0nJHt5fScgXFxcbndpZHRoPScke3dpZHRofScgaGVpZ2h0PScke2hlaWdodH0nIFxcXG5zdHJva2U9JyR7c2hhcGUuc3Ryb2tlQ29sb3J9JyBmaWxsPScke3NoYXBlLmZpbGxDb2xvcn0nIFxcXG5zdHJva2Utd2lkdGg9JyR7c2hhcGUuc3Ryb2tlV2lkdGh9JyAvPlxcXG5gO1xufSk7XG5cbmRlZmluZVNWR1JlbmRlcmVyKFwiU2VsZWN0aW9uQm94XCIsICgpID0+IHt9KTtcblxuZGVmaW5lU1ZHUmVuZGVyZXIoXCJFbGxpcHNlXCIsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgY29uc3QgaGFsZldpZHRoID0gTWF0aC5mbG9vcihzaGFwZS53aWR0aCAvIDIpO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHNoYXBlLmhlaWdodCAvIDIpO1xuICAgIGNvbnN0IGNlbnRlclggPSBzaGFwZS54ICsgaGFsZldpZHRoO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzaGFwZS55ICsgaGFsZkhlaWdodDtcbiAgICByZXR1cm4gYFxcXG48ZWxsaXBzZSBjeD0nJHtjZW50ZXJYfScgY3k9JyR7Y2VudGVyWX0nIHJ4PScke01hdGguYWJzKGhhbGZXaWR0aCl9JyBcXFxucnk9JyR7TWF0aC5hYnMoaGFsZkhlaWdodCl9JyBcXFxuc3Ryb2tlPScke3NoYXBlLnN0cm9rZUNvbG9yfScgZmlsbD0nJHtzaGFwZS5maWxsQ29sb3J9JyBcXFxuc3Ryb2tlLXdpZHRoPScke3NoYXBlLnN0cm9rZVdpZHRofScgLz5cXFxuYDtcbn0pO1xuXG5kZWZpbmVTVkdSZW5kZXJlcihcbiAgICBcIkltYWdlXCIsXG4gICAgc2hhcGUgPT5cbiAgICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgd29yayB3aGVuIGVtYmVkZGVkIGluIGEgd2ViIHBhZ2UuXG4gICAgICAgIGBcXFxuPGltYWdlIHg9JyR7c2hhcGUueH0nIHk9JyR7c2hhcGUueX0nIFxcXG53aWR0aD0nJHtzaGFwZS5pbWFnZS5uYXR1cmFsV2lkdGggKiBzaGFwZS5zY2FsZX0nIFxcXG5oZWlnaHQ9JyR7c2hhcGUuaW1hZ2UubmF0dXJhbEhlaWdodCAqIHNoYXBlLnNjYWxlfScgXFxcbnhsaW5rOmhyZWY9JyR7c2hhcGUuaW1hZ2Uuc3JjfScgLz5cXFxuYCxcbik7XG5cbmRlZmluZVNWR1JlbmRlcmVyKFwiTGluZVwiLCBmdW5jdGlvbihzaGFwZSkge1xuICAgIGNvbnN0IGRhc2hTdHJpbmcgPSBzaGFwZS5kYXNoXG4gICAgICAgID8gYHN0cm9rZS1kYXNoYXJyYXk9JyR7c2hhcGUuZGFzaC5qb2luKFwiLCBcIil9J2BcbiAgICAgICAgOiBcIlwiO1xuICAgIGxldCBjYXBTdHJpbmcgPSBcIlwiO1xuICAgIGNvbnN0IGFycm93V2lkdGggPSBNYXRoLm1heChzaGFwZS5zdHJva2VXaWR0aCAqIDIuMiwgNSk7XG5cbiAgICBsZXQge3gxfSA9IHNoYXBlO1xuICAgIGxldCB7eDJ9ID0gc2hhcGU7XG4gICAgbGV0IHt5MX0gPSBzaGFwZTtcbiAgICBsZXQge3kyfSA9IHNoYXBlO1xuICAgIGlmIChzaGFwZS5zdHJva2VXaWR0aCAlIDIgIT09IDApIHtcbiAgICAgICAgeDEgKz0gMC41O1xuICAgICAgICB4MiArPSAwLjU7XG4gICAgICAgIHkxICs9IDAuNTtcbiAgICAgICAgeTIgKz0gMC41O1xuICAgIH1cblxuICAgIGlmIChzaGFwZS5lbmRDYXBTaGFwZXNbMF0pIHtcbiAgICAgICAgY2FwU3RyaW5nICs9IGxpbmVFbmRDYXBTaGFwZXNbc2hhcGUuZW5kQ2FwU2hhcGVzWzBdXS5zdmcoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgTWF0aC5hdGFuMih5MSAtIHkyLCB4MSAtIHgyKSxcbiAgICAgICAgICAgIGFycm93V2lkdGgsXG4gICAgICAgICAgICBzaGFwZS5jb2xvcixcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHNoYXBlLmVuZENhcFNoYXBlc1sxXSkge1xuICAgICAgICBjYXBTdHJpbmcgKz0gbGluZUVuZENhcFNoYXBlc1tzaGFwZS5lbmRDYXBTaGFwZXNbMV1dLnN2ZyhcbiAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgeTIsXG4gICAgICAgICAgICBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpLFxuICAgICAgICAgICAgYXJyb3dXaWR0aCxcbiAgICAgICAgICAgIHNoYXBlLmNvbG9yLFxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYFxcXG48Zz4gXFxcbjxsaW5lIHgxPScke3gxfScgeTE9JyR7eTF9JyB4Mj0nJHt4Mn0nIHkyPScke3kyfScgXFxcbiR7ZGFzaFN0cmluZ30gXFxcbnN0cm9rZS1saW5lY2FwPScke3NoYXBlLmNhcFN0eWxlfScgXFxcbnN0cm9rZT0nJHtzaGFwZS5jb2xvcn0nIHN0cm9rZS13aWR0aD0nJHtzaGFwZS5zdHJva2VXaWR0aH0nIC8+IFxcXG4ke2NhcFN0cmluZ30gXFxcbjwvZz5cXFxuYDtcbn0pO1xuXG5kZWZpbmVTVkdSZW5kZXJlcihcbiAgICBcIkxpbmVQYXRoXCIsXG4gICAgc2hhcGUgPT5cbiAgICAgICAgYFxcXG48cG9seWxpbmUgXFxcbmZpbGw9J25vbmUnIFxcXG5wb2ludHM9JyR7c2hhcGUuc21vb3RoZWRQb2ludHNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHAuc3Ryb2tlV2lkdGggJSAyID09PSAwID8gMC4wIDogMC41O1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtwLnggKyBvZmZzZXR9LCR7cC55ICsgb2Zmc2V0fWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpfScgXFxcbnN0cm9rZT0nJHtzaGFwZS5wb2ludHNbMF0uY29sb3J9JyBcXFxuc3Ryb2tlLWxpbmVjYXA9J3JvdW5kJyBcXFxuc3Ryb2tlLXdpZHRoPScke3NoYXBlLnBvaW50c1swXS5zaXplfScgLz5cXFxuYCxcbik7XG5cbi8vIHNpbGVudGx5IHNraXAgZXJhc2Vyc1xuZGVmaW5lU1ZHUmVuZGVyZXIoXCJFcmFzZWRMaW5lUGF0aFwiLCAoKSA9PiB7fSk7XG5cbmRlZmluZVNWR1JlbmRlcmVyKFwiUG9seWdvblwiLCBmdW5jdGlvbihzaGFwZSkge1xuICAgIGlmIChzaGFwZS5pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm4gYFxcXG48cG9seWdvbiBcXFxuZmlsbD0nJHtzaGFwZS5maWxsQ29sb3J9JyBcXFxucG9pbnRzPScke3NoYXBlLnBvaW50c1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcC5zdHJva2VXaWR0aCAlIDIgPT09IDAgPyAwLjAgOiAwLjU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3AueCArIG9mZnNldH0sJHtwLnkgKyBvZmZzZXR9YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIiBcIil9JyBcXFxuc3Ryb2tlPScke3NoYXBlLnN0cm9rZUNvbG9yfScgXFxcbnN0cm9rZS13aWR0aD0nJHtzaGFwZS5zdHJva2VXaWR0aH0nIC8+XFxcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBcXFxuPHBvbHlsaW5lIFxcXG5maWxsPScke3NoYXBlLmZpbGxDb2xvcn0nIFxcXG5wb2ludHM9JyR7c2hhcGUucG9pbnRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwLnN0cm9rZVdpZHRoICUgMiA9PT0gMCA/IDAuMCA6IDAuNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cC54ICsgb2Zmc2V0fSwke3AueSArIG9mZnNldH1gO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKX0nIFxcXG5zdHJva2U9J25vbmUnIC8+IFxcXG48cG9seWxpbmUgXFxcbmZpbGw9J25vbmUnIFxcXG5wb2ludHM9JyR7c2hhcGUucG9pbnRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwLnN0cm9rZVdpZHRoICUgMiA9PT0gMCA/IDAuMCA6IDAuNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cC54ICsgb2Zmc2V0fSwke3AueSArIG9mZnNldH1gO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKX0nIFxcXG5zdHJva2U9JyR7c2hhcGUuc3Ryb2tlQ29sb3J9JyBcXFxuc3Ryb2tlLXdpZHRoPScke3NoYXBlLnN0cm9rZVdpZHRofScgLz5cXFxuYDtcbiAgICB9XG59KTtcblxuZGVmaW5lU1ZHUmVuZGVyZXIoXCJUZXh0XCIsIGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgLy8gZmFsbGJhY2s6IGRvbid0IHdvcnJ5IGFib3V0IGF1dG8td3JhcHBpbmdcbiAgICBjb25zdCB3aWR0aFN0cmluZyA9IHNoYXBlLmZvcmNlZFdpZHRoXG4gICAgICAgID8gYHdpZHRoPScke3NoYXBlLmZvcmNlZFdpZHRofXB4J2BcbiAgICAgICAgOiBcIlwiO1xuICAgIGNvbnN0IGhlaWdodFN0cmluZyA9IHNoYXBlLmZvcmNlZEhlaWdodFxuICAgICAgICA/IGBoZWlnaHQ9JyR7c2hhcGUuZm9yY2VkSGVpZ2h0fXB4J2BcbiAgICAgICAgOiBcIlwiO1xuICAgIGxldCB0ZXh0U3BsaXRPbkxpbmVzID0gc2hhcGUudGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyk7XG5cbiAgICBpZiAoc2hhcGUucmVuZGVyZXIpIHtcbiAgICAgICAgdGV4dFNwbGl0T25MaW5lcyA9IHNoYXBlLnJlbmRlcmVyLmxpbmVzO1xuICAgIH1cblxuICAgIHJldHVybiBgXFxcbjx0ZXh0IHg9JyR7c2hhcGUueH0nIHk9JyR7c2hhcGUueX0nIFxcXG4ke3dpZHRoU3RyaW5nfSAke2hlaWdodFN0cmluZ30gXFxcbmZpbGw9JyR7c2hhcGUuY29sb3J9JyBcXFxuc3R5bGU9J2ZvbnQ6ICR7c2hhcGUuZm9udH07Jz4gXFxcbiR7dGV4dFNwbGl0T25MaW5lc1xuICAgICAgICAubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkeSA9IGkgPT09IDAgPyAwIDogXCIxLjJlbVwiO1xuICAgICAgICAgICAgcmV0dXJuIGBcXFxuPHRzcGFuIHg9JyR7c2hhcGUueH0nIGR5PScke2R5fScgYWxpZ25tZW50LWJhc2VsaW5lPSd0ZXh0LWJlZm9yZS1lZGdlJz4gXFxcbiR7ZXNjYXBlSFRNTChsaW5lKX0gXFxcbjwvdHNwYW4+YDtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCJcIil9IFxcXG48L3RleHQ+XFxcbmA7XG59KTtcblxuZXhwb3J0IHtkZWZpbmVTVkdSZW5kZXJlciwgcmVuZGVyU2hhcGVUb1NWR307XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/svgRenderer.js\n",
                );

                /***/
            },

        /***/ "./src/tools/Pencil.js":
            /*!*****************************!*\
  !*** ./src/tools/Pencil.js ***!
  \*****************************/
            /*! exports provided: default */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/tools/base.js");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes */ "./src/shapes.js");\n\n\n\nclass Pencil extends _base__WEBPACK_IMPORTED_MODULE_0__["ToolWithStroke"] {\n    begin(x, y, lc) {\n        this.color = lc.getColor("primary");\n        this.currentShape = this.makeShape();\n        this.currentShape.addPoint(this.makePoint(x, y, lc));\n        this.lastEventTime = Date.now();\n    }\n\n    continue(x, y, lc) {\n        const timeDiff = Date.now() - this.lastEventTime;\n\n        if (timeDiff > this.eventTimeThreshold) {\n            this.lastEventTime += timeDiff;\n            this.currentShape.addPoint(this.makePoint(x, y, lc));\n            lc.drawShapeInProgress(this.currentShape);\n        }\n    }\n\n    end(x, y, lc) {\n        lc.saveShape(this.currentShape);\n        this.currentShape = undefined;\n    }\n\n    makePoint(x, y, lc) {\n        return Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["createShape"])("Point", {\n            x,\n            y,\n            size: this.strokeWidth,\n            color: this.color,\n        });\n    }\n    makeShape() {\n        return Object(_shapes__WEBPACK_IMPORTED_MODULE_1__["createShape"])("LinePath");\n    }\n}\n\nPencil.prototype.name = "Pencil";\nPencil.prototype.iconName = "pencil";\nPencil.prototype.eventTimeThreshold = 10;\n\n/* harmony default export */ __webpack_exports__["default"] = (Pencil);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdG9vbHMvUGVuY2lsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3Rvb2xzL1BlbmNpbC5qcz9mMmFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VG9vbFdpdGhTdHJva2V9IGZyb20gXCIuL2Jhc2VcIjtcbmltcG9ydCB7Y3JlYXRlU2hhcGV9IGZyb20gXCIuLi9zaGFwZXNcIjtcblxuY2xhc3MgUGVuY2lsIGV4dGVuZHMgVG9vbFdpdGhTdHJva2Uge1xuICAgIGJlZ2luKHgsIHksIGxjKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBsYy5nZXRDb2xvcihcInByaW1hcnlcIik7XG4gICAgICAgIHRoaXMuY3VycmVudFNoYXBlID0gdGhpcy5tYWtlU2hhcGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U2hhcGUuYWRkUG9pbnQodGhpcy5tYWtlUG9pbnQoeCwgeSwgbGMpKTtcbiAgICAgICAgdGhpcy5sYXN0RXZlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBjb250aW51ZSh4LCB5LCBsYykge1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IERhdGUubm93KCkgLSB0aGlzLmxhc3RFdmVudFRpbWU7XG5cbiAgICAgICAgaWYgKHRpbWVEaWZmID4gdGhpcy5ldmVudFRpbWVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50VGltZSArPSB0aW1lRGlmZjtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNoYXBlLmFkZFBvaW50KHRoaXMubWFrZVBvaW50KHgsIHksIGxjKSk7XG4gICAgICAgICAgICBsYy5kcmF3U2hhcGVJblByb2dyZXNzKHRoaXMuY3VycmVudFNoYXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZCh4LCB5LCBsYykge1xuICAgICAgICBsYy5zYXZlU2hhcGUodGhpcy5jdXJyZW50U2hhcGUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTaGFwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBtYWtlUG9pbnQoeCwgeSwgbGMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYXBlKFwiUG9pbnRcIiwge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBzaXplOiB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlU2hhcGUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFwZShcIkxpbmVQYXRoXCIpO1xuICAgIH1cbn1cblxuUGVuY2lsLnByb3RvdHlwZS5uYW1lID0gXCJQZW5jaWxcIjtcblBlbmNpbC5wcm90b3R5cGUuaWNvbk5hbWUgPSBcInBlbmNpbFwiO1xuUGVuY2lsLnByb3RvdHlwZS5ldmVudFRpbWVUaHJlc2hvbGQgPSAxMDtcblxuZXhwb3J0IGRlZmF1bHQgUGVuY2lsO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/tools/Pencil.js\n',
                );

                /***/
            },

        /***/ "./src/tools/base.js":
            /*!***************************!*\
  !*** ./src/tools/base.js ***!
  \***************************/
            /*! exports provided: Tool, ToolWithStroke */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tool", function() { return Tool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolWithStroke", function() { return ToolWithStroke; });\nclass Tool {\n    constructor() {}\n\n    // called when the user starts dragging\n    begin(x, y, lc) {}\n\n    // called when the user moves while dragging\n    continue(x, y, lc) {}\n\n    // called when the user finishes dragging\n    end(x, y, lc) {}\n\n    didBecomeActive(lc) {}\n    willBecomeInactive(lc) {}\n}\n\nTool.prototype.name = null; // for debugging\nTool.prototype.iconName = null; // {imageURLPrefix}/{iconName}.png\nTool.prototype.usesSimpleAPI = true;\nTool.prototype.optionsStyle = null; // kind of options GUI to display\n\nclass ToolWithStroke extends Tool {\n    constructor(lc) {\n        super();\n        this.strokeWidth = lc.opts.defaultStrokeWidth;\n    }\n\n    didBecomeActive(lc) {\n        const unsubscribeFuncs = [];\n        this.unsubscribe = () => {\n            unsubscribeFuncs.map(func => func());\n        };\n\n        unsubscribeFuncs.push(\n            lc.on("setStrokeWidth", strokeWidth => {\n                this.strokeWidth = strokeWidth;\n                lc.trigger("toolDidUpdateOptions");\n            }),\n        );\n    }\n\n    willBecomeInactive(lc) {\n        this.unsubscribe();\n    }\n}\n\nToolWithStroke.prototype.optionsStyle = "stroke-width";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdG9vbHMvYmFzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy90b29scy9iYXNlLmpzP2MwM2IiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgVG9vbCB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxuXG4gICAgLy8gY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nXG4gICAgYmVnaW4oeCwgeSwgbGMpIHt9XG5cbiAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB3aGlsZSBkcmFnZ2luZ1xuICAgIGNvbnRpbnVlKHgsIHksIGxjKSB7fVxuXG4gICAgLy8gY2FsbGVkIHdoZW4gdGhlIHVzZXIgZmluaXNoZXMgZHJhZ2dpbmdcbiAgICBlbmQoeCwgeSwgbGMpIHt9XG5cbiAgICBkaWRCZWNvbWVBY3RpdmUobGMpIHt9XG4gICAgd2lsbEJlY29tZUluYWN0aXZlKGxjKSB7fVxufVxuXG5Ub29sLnByb3RvdHlwZS5uYW1lID0gbnVsbDsgLy8gZm9yIGRlYnVnZ2luZ1xuVG9vbC5wcm90b3R5cGUuaWNvbk5hbWUgPSBudWxsOyAvLyB7aW1hZ2VVUkxQcmVmaXh9L3tpY29uTmFtZX0ucG5nXG5Ub29sLnByb3RvdHlwZS51c2VzU2ltcGxlQVBJID0gdHJ1ZTtcblRvb2wucHJvdG90eXBlLm9wdGlvbnNTdHlsZSA9IG51bGw7IC8vIGtpbmQgb2Ygb3B0aW9ucyBHVUkgdG8gZGlzcGxheVxuXG5jbGFzcyBUb29sV2l0aFN0cm9rZSBleHRlbmRzIFRvb2wge1xuICAgIGNvbnN0cnVjdG9yKGxjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBsYy5vcHRzLmRlZmF1bHRTdHJva2VXaWR0aDtcbiAgICB9XG5cbiAgICBkaWRCZWNvbWVBY3RpdmUobGMpIHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVGdW5jcyA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmVGdW5jcy5tYXAoZnVuYyA9PiBmdW5jKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHVuc3Vic2NyaWJlRnVuY3MucHVzaChcbiAgICAgICAgICAgIGxjLm9uKFwic2V0U3Ryb2tlV2lkdGhcIiwgc3Ryb2tlV2lkdGggPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgICBsYy50cmlnZ2VyKFwidG9vbERpZFVwZGF0ZU9wdGlvbnNcIik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB3aWxsQmVjb21lSW5hY3RpdmUobGMpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuVG9vbFdpdGhTdHJva2UucHJvdG90eXBlLm9wdGlvbnNTdHlsZSA9IFwic3Ryb2tlLXdpZHRoXCI7XG5cbmV4cG9ydCB7VG9vbCwgVG9vbFdpdGhTdHJva2V9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/tools/base.js\n',
                );

                /***/
            },

        /***/ "./src/util.js":
            /*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
            /*! exports provided: addImageOnload, last, classSet, matchElementSize, combineCanvases, renderShapes, renderShapesToSVG, getBoundingRect, getDefaultImageRect, getBackingScale, getGUID, requestAnimationFrame, cancelAnimationFrame */
            /***/ function(module, __webpack_exports__, __webpack_require__) {
                "use strict";
                eval(
                    '__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addImageOnload", function() { return addImageOnload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classSet", function() { return classSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchElementSize", function() { return matchElementSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineCanvases", function() { return combineCanvases; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderShapes", function() { return renderShapes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderShapesToSVG", function() { return renderShapesToSVG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingRect", function() { return getBoundingRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageRect", function() { return getDefaultImageRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackingScale", function() { return getBackingScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGUID", function() { return getGUID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return requestAnimationFrame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return cancelAnimationFrame; });\n/* harmony import */ var _canvasRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvasRenderer */ "./src/canvasRenderer.js");\n/* harmony import */ var _svgRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svgRenderer */ "./src/svgRenderer.js");\n\n\n\nfunction addImageOnload(img, fn) {\n    const oldOnload = img.onload;\n    img.onload = function() {\n        if (typeof oldOnload === "function") {\n            oldOnload();\n        }\n        fn();\n    };\n    return img;\n}\n\nfunction last(array, n = null) {\n    if (n) {\n        return Array.prototype.slice.call(array, Math.max(array.length - n, 0));\n    } else {\n        return array[array.length - 1];\n    }\n}\n\nfunction classSet(classNameToIsPresent) {\n    const classNames = [];\n    for (let key in classNameToIsPresent) {\n        if (classNameToIsPresent[key]) {\n            classNames.push(key);\n        }\n    }\n    return classNames.join(" ");\n}\n\nfunction matchElementSize(elementToMatch, elementsToResize, scale, callback) {\n    if (callback == null) {\n        callback = function() {};\n    }\n    const resize = () => {\n        for (let el of elementsToResize) {\n            el.style.width = `${elementToMatch.offsetWidth}px`;\n            el.style.height = `${elementToMatch.offsetHeight}px`;\n            if (el.width != null) {\n                el.setAttribute("width", el.offsetWidth * scale);\n                el.setAttribute("height", el.offsetHeight * scale);\n            }\n        }\n        callback();\n    };\n\n    elementToMatch.addEventListener("resize", resize);\n    window.addEventListener("resize", resize);\n    window.addEventListener("orientationchange", resize);\n    resize();\n    return resize;\n}\n\nfunction combineCanvases(...canvases) {\n    const c = document.createElement("canvas");\n    c.width = canvases[0].width;\n    c.height = canvases[0].height;\n    for (var canvas of canvases) {\n        c.width = Math.max(canvas.width, c.width);\n        c.height = Math.max(canvas.height, c.height);\n    }\n    const ctx = c.getContext("2d");\n\n    for (canvas of canvases) {\n        ctx.drawImage(canvas, 0, 0);\n    }\n    return c;\n}\n\nfunction renderShapes(shapes, bounds, scale, canvas = null) {\n    if (scale == null) {\n        scale = 1;\n    }\n    canvas = canvas || document.createElement("canvas");\n    canvas.width = bounds.width * scale;\n    canvas.height = bounds.height * scale;\n    const ctx = canvas.getContext("2d");\n    ctx.translate(-bounds.x * scale, -bounds.y * scale);\n    ctx.scale(scale, scale);\n    for (let shape of shapes) {\n        Object(_canvasRenderer__WEBPACK_IMPORTED_MODULE_0__["renderShapeToContext"])(ctx, shape);\n    }\n    return canvas;\n}\n\nfunction renderShapesToSVG(shapes, {x, y, width, height}, backgroundColor) {\n    return `\\\n<svg \\\nxmlns=\'http://www.w3.org/2000/svg\' \\\nwidth=\'${width}\' height=\'${height}\' \\\nviewBox=\'0 0 ${width} ${height}\'> \\\n<rect width=\'${width}\' height=\'${height}\' x=\'0\' y=\'0\' \\\nfill=\'${backgroundColor}\' /> \\\n<g transform=\'translate(${-x}, ${-y})\'> \\\n${shapes.map(shape => Object(_svgRenderer__WEBPACK_IMPORTED_MODULE_1__["renderShapeToSVG"])(shape)).join("")} \\\n</g> \\\n</svg>\\\n`.replace(/(\\r\\n|\\n|\\r)/gm, "");\n}\n\n// [{x, y, width, height}]\nfunction getBoundingRect(rects, width, height) {\n    if (!rects.length) {\n        return {x: 0, y: 0, width:  false || width, height:  false || height};\n    }\n\n    // Calculate the bounds for infinite canvas\n    let minX = rects[0].x;\n    let minY = rects[0].y;\n    let maxX = rects[0].x + rects[0].width;\n    let maxY = rects[0].y + rects[0].height;\n    for (let rect of rects) {\n        minX = Math.floor(Math.min(rect.x, minX));\n        minY = Math.floor(Math.min(rect.y, minY));\n        maxX = Math.ceil(Math.max(maxX, rect.x + rect.width));\n        maxY = Math.ceil(Math.max(maxY, rect.y + rect.height));\n    }\n\n    // Use the image size bounds if they exist\n    minX = width ? 0 : minX;\n    minY = height ? 0 : minY;\n    maxX = width || maxX;\n    maxY = height || maxY;\n\n    return {x: minX, y: minY, width: maxX - minX, height: maxY - minY};\n}\n\n// Returns the rect LC will use for exporting images using the given params\nfunction getDefaultImageRect(shapeBoundingRects, explicitSize, margin) {\n    if (explicitSize == null) {\n        explicitSize = {width: 0, height: 0};\n    }\n    if (margin == null) {\n        margin = {top: 0, right: 0, bottom: 0, left: 0};\n    }\n    const {width, height} = explicitSize;\n\n    const rect = getBoundingRect(\n        shapeBoundingRects,\n        width === "infinite" ? 0 : width,\n        height === "infinite" ? 0 : height,\n    );\n\n    rect.x -= margin.left;\n    rect.y -= margin.top;\n    rect.width += margin.left + margin.right;\n    rect.height += margin.top + margin.bottom;\n\n    return rect;\n}\n\nfunction getBackingScale(context) {\n    if (window.devicePixelRatio == null) {\n        return 1;\n    }\n    if (!(window.devicePixelRatio > 1)) {\n        return 1;\n    }\n    return window.devicePixelRatio;\n}\n\nfunction getGUID() {\n    const s4 = () =>\n        Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    return (\n        s4() +\n        s4() +\n        "-" +\n        s4() +\n        "-" +\n        s4() +\n        "-" +\n        s4() +\n        "-" +\n        s4() +\n        s4() +\n        s4()\n    );\n}\n\nfunction requestAnimationFrame(f) {\n    if (window.requestAnimationFrame) {\n        return window.requestAnimationFrame(f);\n    }\n    if (window.webkitRequestAnimationFrame) {\n        return window.webkitRequestAnimationFrame(f);\n    }\n    if (window.mozRequestAnimationFrame) {\n        return window.mozRequestAnimationFrame(f);\n    }\n    return setTimeout(f, 0);\n}\n\nfunction cancelAnimationFrame(f) {\n    if (window.cancelAnimationFrame) {\n        window.cancelAnimationFrame(f);\n    }\n    if (window.webkitCancelRequestAnimationFrame) {\n        window.webkitCancelRequestAnimationFrame(f);\n    }\n    if (window.webkitCancelAnimationFrame) {\n        window.webkitCancelAnimationFrame(f);\n    }\n    if (window.mozCancelAnimationFrame) {\n        window.mozCancelAnimationFrame(f);\n    }\n    clearTimeout(f);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlsLmpzP2UwZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtyZW5kZXJTaGFwZVRvQ29udGV4dH0gZnJvbSBcIi4vY2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCB7cmVuZGVyU2hhcGVUb1NWR30gZnJvbSBcIi4vc3ZnUmVuZGVyZXJcIjtcblxuZnVuY3Rpb24gYWRkSW1hZ2VPbmxvYWQoaW1nLCBmbikge1xuICAgIGNvbnN0IG9sZE9ubG9hZCA9IGltZy5vbmxvYWQ7XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIG9sZE9ubG9hZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvbGRPbmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBmbigpO1xuICAgIH07XG4gICAgcmV0dXJuIGltZztcbn1cblxuZnVuY3Rpb24gbGFzdChhcnJheSwgbiA9IG51bGwpIHtcbiAgICBpZiAobikge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGFzc1NldChjbGFzc05hbWVUb0lzUHJlc2VudCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gY2xhc3NOYW1lVG9Jc1ByZXNlbnQpIHtcbiAgICAgICAgaWYgKGNsYXNzTmFtZVRvSXNQcmVzZW50W2tleV0pIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzLmpvaW4oXCIgXCIpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEVsZW1lbnRTaXplKGVsZW1lbnRUb01hdGNoLCBlbGVtZW50c1RvUmVzaXplLCBzY2FsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIGNvbnN0IHJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgZWxlbWVudHNUb1Jlc2l6ZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50VG9NYXRjaC5vZmZzZXRXaWR0aH1weGA7XG4gICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50VG9NYXRjaC5vZmZzZXRIZWlnaHR9cHhgO1xuICAgICAgICAgICAgaWYgKGVsLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBlbC5vZmZzZXRXaWR0aCAqIHNjYWxlKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgZWwub2Zmc2V0SGVpZ2h0ICogc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGVsZW1lbnRUb01hdGNoLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgcmVzaXplKTtcbiAgICByZXNpemUoKTtcbiAgICByZXR1cm4gcmVzaXplO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQ2FudmFzZXMoLi4uY2FudmFzZXMpIHtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjLndpZHRoID0gY2FudmFzZXNbMF0ud2lkdGg7XG4gICAgYy5oZWlnaHQgPSBjYW52YXNlc1swXS5oZWlnaHQ7XG4gICAgZm9yICh2YXIgY2FudmFzIG9mIGNhbnZhc2VzKSB7XG4gICAgICAgIGMud2lkdGggPSBNYXRoLm1heChjYW52YXMud2lkdGgsIGMud2lkdGgpO1xuICAgICAgICBjLmhlaWdodCA9IE1hdGgubWF4KGNhbnZhcy5oZWlnaHQsIGMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gYy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBmb3IgKGNhbnZhcyBvZiBjYW52YXNlcykge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTaGFwZXMoc2hhcGVzLCBib3VuZHMsIHNjYWxlLCBjYW52YXMgPSBudWxsKSB7XG4gICAgaWYgKHNjYWxlID09IG51bGwpIHtcbiAgICAgICAgc2NhbGUgPSAxO1xuICAgIH1cbiAgICBjYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBib3VuZHMud2lkdGggKiBzY2FsZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAqIHNjYWxlO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LnRyYW5zbGF0ZSgtYm91bmRzLnggKiBzY2FsZSwgLWJvdW5kcy55ICogc2NhbGUpO1xuICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIGZvciAobGV0IHNoYXBlIG9mIHNoYXBlcykge1xuICAgICAgICByZW5kZXJTaGFwZVRvQ29udGV4dChjdHgsIHNoYXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2hhcGVzVG9TVkcoc2hhcGVzLCB7eCwgeSwgd2lkdGgsIGhlaWdodH0sIGJhY2tncm91bmRDb2xvcikge1xuICAgIHJldHVybiBgXFxcbjxzdmcgXFxcbnhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgXFxcbndpZHRoPScke3dpZHRofScgaGVpZ2h0PScke2hlaWdodH0nIFxcXG52aWV3Qm94PScwIDAgJHt3aWR0aH0gJHtoZWlnaHR9Jz4gXFxcbjxyZWN0IHdpZHRoPScke3dpZHRofScgaGVpZ2h0PScke2hlaWdodH0nIHg9JzAnIHk9JzAnIFxcXG5maWxsPScke2JhY2tncm91bmRDb2xvcn0nIC8+IFxcXG48ZyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgkey14fSwgJHsteX0pJz4gXFxcbiR7c2hhcGVzLm1hcChzaGFwZSA9PiByZW5kZXJTaGFwZVRvU1ZHKHNoYXBlKSkuam9pbihcIlwiKX0gXFxcbjwvZz4gXFxcbjwvc3ZnPlxcXG5gLnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sIFwiXCIpO1xufVxuXG4vLyBbe3gsIHksIHdpZHRoLCBoZWlnaHR9XVxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHt4OiAwLCB5OiAwLCB3aWR0aDogMCB8fCB3aWR0aCwgaGVpZ2h0OiAwIHx8IGhlaWdodH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBib3VuZHMgZm9yIGluZmluaXRlIGNhbnZhc1xuICAgIGxldCBtaW5YID0gcmVjdHNbMF0ueDtcbiAgICBsZXQgbWluWSA9IHJlY3RzWzBdLnk7XG4gICAgbGV0IG1heFggPSByZWN0c1swXS54ICsgcmVjdHNbMF0ud2lkdGg7XG4gICAgbGV0IG1heFkgPSByZWN0c1swXS55ICsgcmVjdHNbMF0uaGVpZ2h0O1xuICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgbWluWCA9IE1hdGguZmxvb3IoTWF0aC5taW4ocmVjdC54LCBtaW5YKSk7XG4gICAgICAgIG1pblkgPSBNYXRoLmZsb29yKE1hdGgubWluKHJlY3QueSwgbWluWSkpO1xuICAgICAgICBtYXhYID0gTWF0aC5jZWlsKE1hdGgubWF4KG1heFgsIHJlY3QueCArIHJlY3Qud2lkdGgpKTtcbiAgICAgICAgbWF4WSA9IE1hdGguY2VpbChNYXRoLm1heChtYXhZLCByZWN0LnkgKyByZWN0LmhlaWdodCkpO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgaW1hZ2Ugc2l6ZSBib3VuZHMgaWYgdGhleSBleGlzdFxuICAgIG1pblggPSB3aWR0aCA/IDAgOiBtaW5YO1xuICAgIG1pblkgPSBoZWlnaHQgPyAwIDogbWluWTtcbiAgICBtYXhYID0gd2lkdGggfHwgbWF4WDtcbiAgICBtYXhZID0gaGVpZ2h0IHx8IG1heFk7XG5cbiAgICByZXR1cm4ge3g6IG1pblgsIHk6IG1pblksIHdpZHRoOiBtYXhYIC0gbWluWCwgaGVpZ2h0OiBtYXhZIC0gbWluWX07XG59XG5cbi8vIFJldHVybnMgdGhlIHJlY3QgTEMgd2lsbCB1c2UgZm9yIGV4cG9ydGluZyBpbWFnZXMgdXNpbmcgdGhlIGdpdmVuIHBhcmFtc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEltYWdlUmVjdChzaGFwZUJvdW5kaW5nUmVjdHMsIGV4cGxpY2l0U2l6ZSwgbWFyZ2luKSB7XG4gICAgaWYgKGV4cGxpY2l0U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIGV4cGxpY2l0U2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcbiAgICB9XG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7XG4gICAgICAgIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9O1xuICAgIH1cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBleHBsaWNpdFNpemU7XG5cbiAgICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICBzaGFwZUJvdW5kaW5nUmVjdHMsXG4gICAgICAgIHdpZHRoID09PSBcImluZmluaXRlXCIgPyAwIDogd2lkdGgsXG4gICAgICAgIGhlaWdodCA9PT0gXCJpbmZpbml0ZVwiID8gMCA6IGhlaWdodCxcbiAgICApO1xuXG4gICAgcmVjdC54IC09IG1hcmdpbi5sZWZ0O1xuICAgIHJlY3QueSAtPSBtYXJnaW4udG9wO1xuICAgIHJlY3Qud2lkdGggKz0gbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQ7XG4gICAgcmVjdC5oZWlnaHQgKz0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b207XG5cbiAgICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0QmFja2luZ1NjYWxlKGNvbnRleHQpIHtcbiAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCEod2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xufVxuXG5mdW5jdGlvbiBnZXRHVUlEKCkge1xuICAgIGNvbnN0IHM0ID0gKCkgPT5cbiAgICAgICAgTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgczQoKSArXG4gICAgICAgIHM0KCkgK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIHM0KCkgK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIHM0KCkgK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIHM0KCkgK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIHM0KCkgK1xuICAgICAgICBzNCgpICtcbiAgICAgICAgczQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmKSB7XG4gICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZik7XG4gICAgfVxuICAgIGlmICh3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGYpO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICByZXR1cm4gd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZShmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGYpIHtcbiAgICBpZiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShmKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZShmKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUoZik7XG4gICAgfVxuICAgIGlmICh3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lKGYpO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoZik7XG59XG5cbmV4cG9ydCB7XG4gICAgYWRkSW1hZ2VPbmxvYWQsXG4gICAgbGFzdCxcbiAgICBjbGFzc1NldCxcbiAgICBtYXRjaEVsZW1lbnRTaXplLFxuICAgIGNvbWJpbmVDYW52YXNlcyxcbiAgICByZW5kZXJTaGFwZXMsXG4gICAgcmVuZGVyU2hhcGVzVG9TVkcsXG4gICAgZ2V0Qm91bmRpbmdSZWN0LFxuICAgIGdldERlZmF1bHRJbWFnZVJlY3QsXG4gICAgZ2V0QmFja2luZ1NjYWxlLFxuICAgIGdldEdVSUQsXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/util.js\n',
                );

                /***/
            },

        /******/
    },
);
